// Copyright 2019 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package syncer

import (
	"context"
	"database/sql"

	"github.com/DATA-DOG/go-sqlmock"
	. "github.com/pingcap/check"
	"github.com/pingcap/parser"
	bf "github.com/pingcap/tidb-tools/pkg/binlog-filter"
	"github.com/pingcap/tidb-tools/pkg/filter"

	"github.com/pingcap/dm/pkg/conn"
)

type testFilterSuite struct {
	baseConn *conn.BaseConn
	db       *sql.DB
}

var _ = Suite(&testFilterSuite{})

func (s *testFilterSuite) SetUpSuite(c *C) {
	db, mock, err := sqlmock.New()
	c.Assert(err, IsNil)
	s.db = db
	mock.ExpectClose()
	con, err := db.Conn(context.Background())
	c.Assert(err, IsNil)
	s.baseConn = conn.NewBaseConn(con, nil)
}

func (s *testFilterSuite) TearDownSuite(c *C) {
	c.Assert(s.baseConn.DBConn.Close(), IsNil)
	c.Assert(s.db.Close(), IsNil)
}

func (s *testFilterSuite) TestSkipQueryEvent(c *C) {
	syncer := &Syncer{}
	// build in skipDDL
	skipped, err := syncer.skipQuery(nil, nil, "DROP TEMPORARY TABLE IF EXISTS `foo`.`bar` /* generated by server */")
	c.Assert(err, IsNil)
	c.Assert(skipped, IsTrue)

	// system table
	skipped, err = syncer.skipQuery([]*filter.Table{{Schema: "mysql", Name: "test"}}, nil, "create table mysql.test (id int)")
	c.Assert(err, IsNil)
	c.Assert(skipped, IsTrue)

	// test binlog filter
	filterRules := []*bf.BinlogEventRule{
		{
			SchemaPattern: "*",
			TablePattern:  "",
			Events:        []bf.EventType{bf.DropTable},
			SQLPattern:    []string{"^drop\\s+table"},
			Action:        bf.Ignore,
		}, {
			SchemaPattern: "foo*",
			TablePattern:  "",
			Events:        []bf.EventType{bf.CreateTable},
			SQLPattern:    []string{"^create\\s+table"},
			Action:        bf.Do,
		}, {
			SchemaPattern: "foo*",
			TablePattern:  "bar*",
			Events:        []bf.EventType{bf.CreateTable},
			SQLPattern:    []string{"^create\\s+table"},
			Action:        bf.Ignore,
		},
	}

	syncer.binlogFilter, err = bf.NewBinlogEvent(false, filterRules)
	c.Assert(err, IsNil)

	cases := []struct {
		sql           string
		tables        []*filter.Table
		expectSkipped bool
	}{
		// test global rule
		{
			"drop table tx.test",
			[]*filter.Table{{Schema: "tx", Name: "test"}},
			true,
		},
		{
			"create table tx.test (id int)",
			[]*filter.Table{{Schema: "tx", Name: "test"}},
			false,
		},
		// test schema rule
		{
			"create table foo.test(id int)",
			[]*filter.Table{{Schema: "foo", Name: "test"}},
			false,
		},
		{
			"rename table foo.test to foo.test1",
			[]*filter.Table{{Schema: "foo", Name: "test"}},
			true,
		},
		// test table rule
		{
			"create table foo.bar(id int)",
			[]*filter.Table{{Schema: "foo", Name: "bar"}},
			true,
		},
	}
	p := parser.New()
	for _, ca := range cases {
		stmt, err := p.ParseOneStmt(ca.sql, "", "")
		c.Assert(err, IsNil)
		skipped, err = syncer.skipQuery(ca.tables, stmt, ca.sql)
		c.Assert(err, IsNil)
		c.Assert(skipped, Equals, ca.expectSkipped)
	}
}
