// Copyright 2019 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

// binlog events generator for MySQL used to generate some binlog events for tests.
// Readability takes precedence over performance.

package event

import (
	"bytes"
	"encoding/binary"
	"hash/crc32"

	"github.com/pingcap/errors"
	"github.com/siddontang/go-mysql/replication"
)

const (
	binlogVersion   uint16 = 4 // only binlog-version 4 supported now
	mysqlVersion           = "5.7.22-log"
	mysqlVersionLen        = 50 // fix-length
	eventHeaderLen  uint8  = 19 // always 19
)

var (
	// A array indexed by `Binlog-Event-Type - 1` to extract the length of the event specific header.
	// It is copied from a binlog file generated by MySQL 5.7.22-log.
	// The doc at https://dev.mysql.com/doc/internals/en/format-description-event.html does not include all of them.
	eventTypeHeaderLen = []byte{0x38, 0x0d, 0x00, 0x08, 0x00, 0x12, 0x00, 0x04, 0x04, 0x04, 0x04, 0x12, 0x00, 0x00, 0x5f, 0x00, 0x04, 0x1a, 0x08, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x2a, 0x2a, 0x00, 0x12, 0x34, 0x00, 0x01}
)

// GenEventHeader generates a EventHeader.
// ref: https://dev.mysql.com/doc/internals/en/binlog-event-header.html
func GenEventHeader(timestamp uint32, eventType replication.EventType, serverID uint32, eventSize uint32, logPos uint32, flags uint16) (*replication.EventHeader, []byte, error) {
	buf := new(bytes.Buffer)

	// timestamp, 4 bytes
	err := binary.Write(buf, binary.LittleEndian, timestamp)
	if err != nil {
		return nil, nil, errors.Annotatef(err, "write timestamp %d", timestamp)
	}

	// event_type, 1 byte
	err = binary.Write(buf, binary.LittleEndian, eventType)
	if err != nil {
		return nil, nil, errors.Annotatef(err, "write event_type %v", eventType)
	}

	// server_id, 4 bytes
	err = binary.Write(buf, binary.LittleEndian, serverID)
	if err != nil {
		return nil, nil, errors.Annotatef(err, "write server_id %d", serverID)
	}

	// event_size, 4 bytes
	err = binary.Write(buf, binary.LittleEndian, eventSize)
	if err != nil {
		return nil, nil, errors.Annotatef(err, "write event_size %d", eventSize)
	}

	// log_pos, 4 bytes
	err = binary.Write(buf, binary.LittleEndian, logPos)
	if err != nil {
		return nil, nil, errors.Annotatef(err, "write log_pos %d", logPos)
	}

	// flags, 2 bytes
	err = binary.Write(buf, binary.LittleEndian, flags)
	if err != nil {
		return nil, nil, errors.Annotatef(err, "write flags % X", flags)
	}

	eh := replication.EventHeader{}
	err = eh.Decode(buf.Bytes())
	if err != nil {
		return nil, nil, errors.Annotatef(err, "decode % X", buf.Bytes())
	}

	return &eh, buf.Bytes(), nil
}

// GenFormatDescriptionEvent generates a FormatDescriptionEvent.
// ref: https://dev.mysql.com/doc/internals/en/format-description-event.html.
func GenFormatDescriptionEvent(timestamp uint32, serverID uint32, latestPos uint32, flags uint16) (*replication.BinlogEvent, error) {
	buf := new(bytes.Buffer)

	// size of the event (header, post-header, body, CRC32), 119 now
	eventSize := uint32(eventHeaderLen) + 2 + 50 + 4 + 1 + 39 + 4

	// position of the next event
	logPos := latestPos + eventSize

	// generate header, `eventHeaderLen` bytes
	header, headerData, err := GenEventHeader(timestamp, replication.FORMAT_DESCRIPTION_EVENT, serverID, eventSize, logPos, flags)
	if err != nil {
		return nil, errors.Annotatef(err, "generate event header")
	}
	err = binary.Write(buf, binary.LittleEndian, headerData)
	if err != nil {
		return nil, errors.Annotatef(err, "write event header % X", headerData)
	}

	// binlog-version, 2 bytes
	err = binary.Write(buf, binary.LittleEndian, binlogVersion)
	if err != nil {
		return nil, errors.Annotatef(err, "write binlog-version %d", binlogVersion)
	}

	// mysql-server version, 50 bytes
	serverVer := make([]byte, mysqlVersionLen)
	copy(serverVer, []byte(mysqlVersion))
	err = binary.Write(buf, binary.LittleEndian, serverVer)
	if err != nil {
		return nil, errors.Annotatef(err, "write mysql-server %v", serverVer)
	}

	// create_timestamp, 4 bytes
	err = binary.Write(buf, binary.LittleEndian, timestamp)
	if err != nil {
		return nil, errors.Annotatef(err, "write create_timestamp %d", timestamp)
	}

	// event_header_length, 1 byte
	err = binary.Write(buf, binary.LittleEndian, eventHeaderLen)
	if err != nil {
		return nil, errors.Annotatef(err, "write event_header_length %d", eventHeaderLen)
	}

	// event type header length, 39 bytes now
	err = binary.Write(buf, binary.LittleEndian, eventTypeHeaderLen)
	if err != nil {
		return nil, errors.Annotatef(err, "write event type header length % X", eventTypeHeaderLen)
	}

	// CRC32 checksum, 4 bytes
	checksum := crc32.ChecksumIEEE(buf.Bytes())
	err = binary.Write(buf, binary.LittleEndian, checksum)
	if err != nil {
		return nil, errors.Annotatef(err, "write CRC32 % X", checksum)
	}

	// decode event
	event := &replication.FormatDescriptionEvent{}
	err = event.Decode(buf.Bytes()[eventHeaderLen:])
	if err != nil {
		return nil, errors.Annotatef(err, "decode % X", buf.Bytes())
	}

	return &replication.BinlogEvent{RawData: buf.Bytes(), Header: header, Event: event}, nil
}
