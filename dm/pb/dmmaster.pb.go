// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dmmaster.proto

package pb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SourceOp int32

const (
	SourceOp_InvalidSourceOp SourceOp = 0
	SourceOp_StartSource     SourceOp = 1
	SourceOp_UpdateSource    SourceOp = 2
	SourceOp_StopSource      SourceOp = 3
)

var SourceOp_name = map[int32]string{
	0: "InvalidSourceOp",
	1: "StartSource",
	2: "UpdateSource",
	3: "StopSource",
}

var SourceOp_value = map[string]int32{
	"InvalidSourceOp": 0,
	"StartSource":     1,
	"UpdateSource":    2,
	"StopSource":      3,
}

func (x SourceOp) String() string {
	return proto.EnumName(SourceOp_name, int32(x))
}

func (SourceOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{0}
}

type MigrateWorkerRelayRequest struct {
	BinlogName string `protobuf:"bytes,1,opt,name=BinlogName,proto3" json:"BinlogName,omitempty"`
	BinlogPos  uint32 `protobuf:"varint,2,opt,name=BinlogPos,proto3" json:"BinlogPos,omitempty"`
	Source     string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *MigrateWorkerRelayRequest) Reset()         { *m = MigrateWorkerRelayRequest{} }
func (m *MigrateWorkerRelayRequest) String() string { return proto.CompactTextString(m) }
func (*MigrateWorkerRelayRequest) ProtoMessage()    {}
func (*MigrateWorkerRelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{0}
}
func (m *MigrateWorkerRelayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateWorkerRelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrateWorkerRelayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrateWorkerRelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateWorkerRelayRequest.Merge(m, src)
}
func (m *MigrateWorkerRelayRequest) XXX_Size() int {
	return m.Size()
}
func (m *MigrateWorkerRelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateWorkerRelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateWorkerRelayRequest proto.InternalMessageInfo

func (m *MigrateWorkerRelayRequest) GetBinlogName() string {
	if m != nil {
		return m.BinlogName
	}
	return ""
}

func (m *MigrateWorkerRelayRequest) GetBinlogPos() uint32 {
	if m != nil {
		return m.BinlogPos
	}
	return 0
}

func (m *MigrateWorkerRelayRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type UpdateWorkerRelayConfigRequest struct {
	Config string `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	Source string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *UpdateWorkerRelayConfigRequest) Reset()         { *m = UpdateWorkerRelayConfigRequest{} }
func (m *UpdateWorkerRelayConfigRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateWorkerRelayConfigRequest) ProtoMessage()    {}
func (*UpdateWorkerRelayConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{1}
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateWorkerRelayConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateWorkerRelayConfigRequest.Merge(m, src)
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateWorkerRelayConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateWorkerRelayConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateWorkerRelayConfigRequest proto.InternalMessageInfo

func (m *UpdateWorkerRelayConfigRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *UpdateWorkerRelayConfigRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type StartTaskRequest struct {
	Task       string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Sources    []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
	RemoveMeta bool     `protobuf:"varint,3,opt,name=removeMeta,proto3" json:"removeMeta,omitempty"`
}

func (m *StartTaskRequest) Reset()         { *m = StartTaskRequest{} }
func (m *StartTaskRequest) String() string { return proto.CompactTextString(m) }
func (*StartTaskRequest) ProtoMessage()    {}
func (*StartTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{2}
}
func (m *StartTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTaskRequest.Merge(m, src)
}
func (m *StartTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartTaskRequest proto.InternalMessageInfo

func (m *StartTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *StartTaskRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *StartTaskRequest) GetRemoveMeta() bool {
	if m != nil {
		return m.RemoveMeta
	}
	return false
}

type StartTaskResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *StartTaskResponse) Reset()         { *m = StartTaskResponse{} }
func (m *StartTaskResponse) String() string { return proto.CompactTextString(m) }
func (*StartTaskResponse) ProtoMessage()    {}
func (*StartTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{3}
}
func (m *StartTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTaskResponse.Merge(m, src)
}
func (m *StartTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartTaskResponse proto.InternalMessageInfo

func (m *StartTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *StartTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *StartTaskResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type UpdateMasterConfigRequest struct {
	Config string `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *UpdateMasterConfigRequest) Reset()         { *m = UpdateMasterConfigRequest{} }
func (m *UpdateMasterConfigRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateMasterConfigRequest) ProtoMessage()    {}
func (*UpdateMasterConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{4}
}
func (m *UpdateMasterConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMasterConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMasterConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMasterConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMasterConfigRequest.Merge(m, src)
}
func (m *UpdateMasterConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMasterConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMasterConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMasterConfigRequest proto.InternalMessageInfo

func (m *UpdateMasterConfigRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

type UpdateMasterConfigResponse struct {
	Result  bool                   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*QueryStatusResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *UpdateMasterConfigResponse) Reset()         { *m = UpdateMasterConfigResponse{} }
func (m *UpdateMasterConfigResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateMasterConfigResponse) ProtoMessage()    {}
func (*UpdateMasterConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{5}
}
func (m *UpdateMasterConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMasterConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMasterConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMasterConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMasterConfigResponse.Merge(m, src)
}
func (m *UpdateMasterConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMasterConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMasterConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMasterConfigResponse proto.InternalMessageInfo

func (m *UpdateMasterConfigResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UpdateMasterConfigResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UpdateMasterConfigResponse) GetSources() []*QueryStatusResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type OperateTaskRequest struct {
	Op      TaskOp   `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Name    string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sources []string `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateTaskRequest) Reset()         { *m = OperateTaskRequest{} }
func (m *OperateTaskRequest) String() string { return proto.CompactTextString(m) }
func (*OperateTaskRequest) ProtoMessage()    {}
func (*OperateTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{6}
}
func (m *OperateTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateTaskRequest.Merge(m, src)
}
func (m *OperateTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateTaskRequest proto.InternalMessageInfo

func (m *OperateTaskRequest) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperateTaskRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type OperateTaskResponse struct {
	Op      TaskOp                  `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Result  bool                    `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,4,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateTaskResponse) Reset()         { *m = OperateTaskResponse{} }
func (m *OperateTaskResponse) String() string { return proto.CompactTextString(m) }
func (*OperateTaskResponse) ProtoMessage()    {}
func (*OperateTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{7}
}
func (m *OperateTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateTaskResponse.Merge(m, src)
}
func (m *OperateTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateTaskResponse proto.InternalMessageInfo

func (m *OperateTaskResponse) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateTaskResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// UpdateTaskRequest used to update task after it has beed started
// task: task's configuration, yaml format
//       now, only support to update config for routes, filters, column-mappings, black-white-list
//       support update partial config for syncer, loader, etc later
// sources need to do update, empty for all sources in processing the task
type UpdateTaskRequest struct {
	Task    string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *UpdateTaskRequest) Reset()         { *m = UpdateTaskRequest{} }
func (m *UpdateTaskRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateTaskRequest) ProtoMessage()    {}
func (*UpdateTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{8}
}
func (m *UpdateTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTaskRequest.Merge(m, src)
}
func (m *UpdateTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTaskRequest proto.InternalMessageInfo

func (m *UpdateTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *UpdateTaskRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type UpdateTaskResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *UpdateTaskResponse) Reset()         { *m = UpdateTaskResponse{} }
func (m *UpdateTaskResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateTaskResponse) ProtoMessage()    {}
func (*UpdateTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{9}
}
func (m *UpdateTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTaskResponse.Merge(m, src)
}
func (m *UpdateTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTaskResponse proto.InternalMessageInfo

func (m *UpdateTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UpdateTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UpdateTaskResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryStatusListRequest struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryStatusListRequest) Reset()         { *m = QueryStatusListRequest{} }
func (m *QueryStatusListRequest) String() string { return proto.CompactTextString(m) }
func (*QueryStatusListRequest) ProtoMessage()    {}
func (*QueryStatusListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{10}
}
func (m *QueryStatusListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStatusListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStatusListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryStatusListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStatusListRequest.Merge(m, src)
}
func (m *QueryStatusListRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryStatusListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStatusListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStatusListRequest proto.InternalMessageInfo

func (m *QueryStatusListRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryStatusListRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryStatusListResponse struct {
	Result  bool                   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*QueryStatusResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryStatusListResponse) Reset()         { *m = QueryStatusListResponse{} }
func (m *QueryStatusListResponse) String() string { return proto.CompactTextString(m) }
func (*QueryStatusListResponse) ProtoMessage()    {}
func (*QueryStatusListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{11}
}
func (m *QueryStatusListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStatusListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStatusListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryStatusListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStatusListResponse.Merge(m, src)
}
func (m *QueryStatusListResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryStatusListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStatusListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStatusListResponse proto.InternalMessageInfo

func (m *QueryStatusListResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *QueryStatusListResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *QueryStatusListResponse) GetSources() []*QueryStatusResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryErrorListRequest struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryErrorListRequest) Reset()         { *m = QueryErrorListRequest{} }
func (m *QueryErrorListRequest) String() string { return proto.CompactTextString(m) }
func (*QueryErrorListRequest) ProtoMessage()    {}
func (*QueryErrorListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{12}
}
func (m *QueryErrorListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryErrorListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryErrorListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryErrorListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryErrorListRequest.Merge(m, src)
}
func (m *QueryErrorListRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryErrorListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryErrorListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryErrorListRequest proto.InternalMessageInfo

func (m *QueryErrorListRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryErrorListRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryErrorListResponse struct {
	Result  bool                  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*QueryErrorResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryErrorListResponse) Reset()         { *m = QueryErrorListResponse{} }
func (m *QueryErrorListResponse) String() string { return proto.CompactTextString(m) }
func (*QueryErrorListResponse) ProtoMessage()    {}
func (*QueryErrorListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{13}
}
func (m *QueryErrorListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryErrorListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryErrorListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryErrorListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryErrorListResponse.Merge(m, src)
}
func (m *QueryErrorListResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryErrorListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryErrorListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryErrorListResponse proto.InternalMessageInfo

func (m *QueryErrorListResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *QueryErrorListResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *QueryErrorListResponse) GetSources() []*QueryErrorResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// ShowDDLLocksRequest used to query DDL locks which are un-resolved
// task: task's name, empty for all tasks
// sources: source need to query, empty for all sources
//          any DDL lock in which the source is synced or unsynced will return
// if specify task and sources both, and sources not doing the task , it will return empty DDL locks
type ShowDDLLocksRequest struct {
	Task    string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *ShowDDLLocksRequest) Reset()         { *m = ShowDDLLocksRequest{} }
func (m *ShowDDLLocksRequest) String() string { return proto.CompactTextString(m) }
func (*ShowDDLLocksRequest) ProtoMessage()    {}
func (*ShowDDLLocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{14}
}
func (m *ShowDDLLocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDDLLocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDDLLocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowDDLLocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDDLLocksRequest.Merge(m, src)
}
func (m *ShowDDLLocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ShowDDLLocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDDLLocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDDLLocksRequest proto.InternalMessageInfo

func (m *ShowDDLLocksRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *ShowDDLLocksRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

// DDLLock represents a DDL lock info (I known the name confused with DDLLockInfo, any suggestion?)
// it been sent from dm-master to dmctl
// ID: DDL lock generated ID
// task: lock's corresponding task name
// mode: the shard DDL mode, `pessimistic` or `optimistic`.
// owner: lock's owner, a dm-worker
// DDL: DDL statement
// synced: already synced dm-workers
// unsynced: pending to sync dm-workers
type DDLLock struct {
	ID       string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Task     string   `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
	Mode     string   `protobuf:"bytes,3,opt,name=mode,proto3" json:"mode,omitempty"`
	Owner    string   `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
	DDLs     []string `protobuf:"bytes,5,rep,name=DDLs,proto3" json:"DDLs,omitempty"`
	Synced   []string `protobuf:"bytes,6,rep,name=synced,proto3" json:"synced,omitempty"`
	Unsynced []string `protobuf:"bytes,7,rep,name=unsynced,proto3" json:"unsynced,omitempty"`
}

func (m *DDLLock) Reset()         { *m = DDLLock{} }
func (m *DDLLock) String() string { return proto.CompactTextString(m) }
func (*DDLLock) ProtoMessage()    {}
func (*DDLLock) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{15}
}
func (m *DDLLock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DDLLock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DDLLock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DDLLock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDLLock.Merge(m, src)
}
func (m *DDLLock) XXX_Size() int {
	return m.Size()
}
func (m *DDLLock) XXX_DiscardUnknown() {
	xxx_messageInfo_DDLLock.DiscardUnknown(m)
}

var xxx_messageInfo_DDLLock proto.InternalMessageInfo

func (m *DDLLock) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *DDLLock) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *DDLLock) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *DDLLock) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DDLLock) GetDDLs() []string {
	if m != nil {
		return m.DDLs
	}
	return nil
}

func (m *DDLLock) GetSynced() []string {
	if m != nil {
		return m.Synced
	}
	return nil
}

func (m *DDLLock) GetUnsynced() []string {
	if m != nil {
		return m.Unsynced
	}
	return nil
}

type ShowDDLLocksResponse struct {
	Result bool       `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Locks  []*DDLLock `protobuf:"bytes,3,rep,name=locks,proto3" json:"locks,omitempty"`
}

func (m *ShowDDLLocksResponse) Reset()         { *m = ShowDDLLocksResponse{} }
func (m *ShowDDLLocksResponse) String() string { return proto.CompactTextString(m) }
func (*ShowDDLLocksResponse) ProtoMessage()    {}
func (*ShowDDLLocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{16}
}
func (m *ShowDDLLocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDDLLocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDDLLocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowDDLLocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDDLLocksResponse.Merge(m, src)
}
func (m *ShowDDLLocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *ShowDDLLocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDDLLocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDDLLocksResponse proto.InternalMessageInfo

func (m *ShowDDLLocksResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ShowDDLLocksResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ShowDDLLocksResponse) GetLocks() []*DDLLock {
	if m != nil {
		return m.Locks
	}
	return nil
}

// UnlockDDLLockRequest used to unlock (resolve) DDL lock manually
// ID: DDL lock ID
// replaceOwner: dm-worker used to replace the original DDL lock's owner
// forceRemove: force to remove the DDL lock even fail to execute the DDL for the owner.
type UnlockDDLLockRequest struct {
	ID           string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ReplaceOwner string `protobuf:"bytes,2,opt,name=replaceOwner,proto3" json:"replaceOwner,omitempty"`
	ForceRemove  bool   `protobuf:"varint,3,opt,name=forceRemove,proto3" json:"forceRemove,omitempty"`
}

func (m *UnlockDDLLockRequest) Reset()         { *m = UnlockDDLLockRequest{} }
func (m *UnlockDDLLockRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockDDLLockRequest) ProtoMessage()    {}
func (*UnlockDDLLockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{17}
}
func (m *UnlockDDLLockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockDDLLockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockDDLLockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockDDLLockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockDDLLockRequest.Merge(m, src)
}
func (m *UnlockDDLLockRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockDDLLockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockDDLLockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockDDLLockRequest proto.InternalMessageInfo

func (m *UnlockDDLLockRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *UnlockDDLLockRequest) GetReplaceOwner() string {
	if m != nil {
		return m.ReplaceOwner
	}
	return ""
}

func (m *UnlockDDLLockRequest) GetForceRemove() bool {
	if m != nil {
		return m.ForceRemove
	}
	return false
}

type UnlockDDLLockResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *UnlockDDLLockResponse) Reset()         { *m = UnlockDDLLockResponse{} }
func (m *UnlockDDLLockResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockDDLLockResponse) ProtoMessage()    {}
func (*UnlockDDLLockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{18}
}
func (m *UnlockDDLLockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockDDLLockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockDDLLockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockDDLLockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockDDLLockResponse.Merge(m, src)
}
func (m *UnlockDDLLockResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockDDLLockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockDDLLockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockDDLLockResponse proto.InternalMessageInfo

func (m *UnlockDDLLockResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UnlockDDLLockResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// SwitchWorkerRelayMasterRequest represents a request for some dm-workers to switch relay unit's master server
// workers: relay unit in these dm-workers need to switch master server
type SwitchWorkerRelayMasterRequest struct {
	Sources []string `protobuf:"bytes,1,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *SwitchWorkerRelayMasterRequest) Reset()         { *m = SwitchWorkerRelayMasterRequest{} }
func (m *SwitchWorkerRelayMasterRequest) String() string { return proto.CompactTextString(m) }
func (*SwitchWorkerRelayMasterRequest) ProtoMessage()    {}
func (*SwitchWorkerRelayMasterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{19}
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWorkerRelayMasterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWorkerRelayMasterRequest.Merge(m, src)
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWorkerRelayMasterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWorkerRelayMasterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWorkerRelayMasterRequest proto.InternalMessageInfo

func (m *SwitchWorkerRelayMasterRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type SwitchWorkerRelayMasterResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *SwitchWorkerRelayMasterResponse) Reset()         { *m = SwitchWorkerRelayMasterResponse{} }
func (m *SwitchWorkerRelayMasterResponse) String() string { return proto.CompactTextString(m) }
func (*SwitchWorkerRelayMasterResponse) ProtoMessage()    {}
func (*SwitchWorkerRelayMasterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{20}
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWorkerRelayMasterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWorkerRelayMasterResponse.Merge(m, src)
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWorkerRelayMasterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWorkerRelayMasterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWorkerRelayMasterResponse proto.InternalMessageInfo

func (m *SwitchWorkerRelayMasterResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *SwitchWorkerRelayMasterResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SwitchWorkerRelayMasterResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// OperateWorkerRelayRequest represents a request for some dm-workers to operate relay unit
type OperateWorkerRelayRequest struct {
	Op      RelayOp  `protobuf:"varint,1,opt,name=op,proto3,enum=pb.RelayOp" json:"op,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateWorkerRelayRequest) Reset()         { *m = OperateWorkerRelayRequest{} }
func (m *OperateWorkerRelayRequest) String() string { return proto.CompactTextString(m) }
func (*OperateWorkerRelayRequest) ProtoMessage()    {}
func (*OperateWorkerRelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{21}
}
func (m *OperateWorkerRelayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateWorkerRelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateWorkerRelayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateWorkerRelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateWorkerRelayRequest.Merge(m, src)
}
func (m *OperateWorkerRelayRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateWorkerRelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateWorkerRelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateWorkerRelayRequest proto.InternalMessageInfo

func (m *OperateWorkerRelayRequest) GetOp() RelayOp {
	if m != nil {
		return m.Op
	}
	return RelayOp_InvalidRelayOp
}

func (m *OperateWorkerRelayRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type OperateWorkerRelayResponse struct {
	Op      RelayOp                 `protobuf:"varint,1,opt,name=op,proto3,enum=pb.RelayOp" json:"op,omitempty"`
	Result  bool                    `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,4,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateWorkerRelayResponse) Reset()         { *m = OperateWorkerRelayResponse{} }
func (m *OperateWorkerRelayResponse) String() string { return proto.CompactTextString(m) }
func (*OperateWorkerRelayResponse) ProtoMessage()    {}
func (*OperateWorkerRelayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{22}
}
func (m *OperateWorkerRelayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateWorkerRelayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateWorkerRelayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateWorkerRelayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateWorkerRelayResponse.Merge(m, src)
}
func (m *OperateWorkerRelayResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateWorkerRelayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateWorkerRelayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateWorkerRelayResponse proto.InternalMessageInfo

func (m *OperateWorkerRelayResponse) GetOp() RelayOp {
	if m != nil {
		return m.Op
	}
	return RelayOp_InvalidRelayOp
}

func (m *OperateWorkerRelayResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateWorkerRelayResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateWorkerRelayResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type HandleSQLsRequest struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Op         SQLOp    `protobuf:"varint,2,opt,name=op,proto3,enum=pb.SQLOp" json:"op,omitempty"`
	Args       []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	BinlogPos  string   `protobuf:"bytes,4,opt,name=binlogPos,proto3" json:"binlogPos,omitempty"`
	Source     string   `protobuf:"bytes,5,opt,name=source,proto3" json:"source,omitempty"`
	SqlPattern string   `protobuf:"bytes,6,opt,name=sqlPattern,proto3" json:"sqlPattern,omitempty"`
	Sharding   bool     `protobuf:"varint,7,opt,name=sharding,proto3" json:"sharding,omitempty"`
}

func (m *HandleSQLsRequest) Reset()         { *m = HandleSQLsRequest{} }
func (m *HandleSQLsRequest) String() string { return proto.CompactTextString(m) }
func (*HandleSQLsRequest) ProtoMessage()    {}
func (*HandleSQLsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{23}
}
func (m *HandleSQLsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleSQLsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleSQLsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandleSQLsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleSQLsRequest.Merge(m, src)
}
func (m *HandleSQLsRequest) XXX_Size() int {
	return m.Size()
}
func (m *HandleSQLsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleSQLsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HandleSQLsRequest proto.InternalMessageInfo

func (m *HandleSQLsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HandleSQLsRequest) GetOp() SQLOp {
	if m != nil {
		return m.Op
	}
	return SQLOp_SKIP
}

func (m *HandleSQLsRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *HandleSQLsRequest) GetBinlogPos() string {
	if m != nil {
		return m.BinlogPos
	}
	return ""
}

func (m *HandleSQLsRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *HandleSQLsRequest) GetSqlPattern() string {
	if m != nil {
		return m.SqlPattern
	}
	return ""
}

func (m *HandleSQLsRequest) GetSharding() bool {
	if m != nil {
		return m.Sharding
	}
	return false
}

type HandleSQLsResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *HandleSQLsResponse) Reset()         { *m = HandleSQLsResponse{} }
func (m *HandleSQLsResponse) String() string { return proto.CompactTextString(m) }
func (*HandleSQLsResponse) ProtoMessage()    {}
func (*HandleSQLsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{24}
}
func (m *HandleSQLsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleSQLsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleSQLsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandleSQLsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleSQLsResponse.Merge(m, src)
}
func (m *HandleSQLsResponse) XXX_Size() int {
	return m.Size()
}
func (m *HandleSQLsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleSQLsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HandleSQLsResponse proto.InternalMessageInfo

func (m *HandleSQLsResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *HandleSQLsResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *HandleSQLsResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// PurgeWorkerRelayRequest represents a request to purge relay log files for some dm-workers
// workers: dm-workers need to purge relay log files
// inactive: whether purge inactive relay log files
// time: whether purge relay log files before this time, the number of seconds elapsed since January 1, 1970 UTC
// filename: whether purge relay log files before this filename
// subDir: specify relay sub directory for @filename
type PurgeWorkerRelayRequest struct {
	Sources  []string `protobuf:"bytes,1,rep,name=sources,proto3" json:"sources,omitempty"`
	Inactive bool     `protobuf:"varint,2,opt,name=inactive,proto3" json:"inactive,omitempty"`
	Time     int64    `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	Filename string   `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	SubDir   string   `protobuf:"bytes,5,opt,name=subDir,proto3" json:"subDir,omitempty"`
}

func (m *PurgeWorkerRelayRequest) Reset()         { *m = PurgeWorkerRelayRequest{} }
func (m *PurgeWorkerRelayRequest) String() string { return proto.CompactTextString(m) }
func (*PurgeWorkerRelayRequest) ProtoMessage()    {}
func (*PurgeWorkerRelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{25}
}
func (m *PurgeWorkerRelayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurgeWorkerRelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurgeWorkerRelayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurgeWorkerRelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurgeWorkerRelayRequest.Merge(m, src)
}
func (m *PurgeWorkerRelayRequest) XXX_Size() int {
	return m.Size()
}
func (m *PurgeWorkerRelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PurgeWorkerRelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PurgeWorkerRelayRequest proto.InternalMessageInfo

func (m *PurgeWorkerRelayRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *PurgeWorkerRelayRequest) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

func (m *PurgeWorkerRelayRequest) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PurgeWorkerRelayRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *PurgeWorkerRelayRequest) GetSubDir() string {
	if m != nil {
		return m.SubDir
	}
	return ""
}

type PurgeWorkerRelayResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *PurgeWorkerRelayResponse) Reset()         { *m = PurgeWorkerRelayResponse{} }
func (m *PurgeWorkerRelayResponse) String() string { return proto.CompactTextString(m) }
func (*PurgeWorkerRelayResponse) ProtoMessage()    {}
func (*PurgeWorkerRelayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{26}
}
func (m *PurgeWorkerRelayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurgeWorkerRelayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurgeWorkerRelayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurgeWorkerRelayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurgeWorkerRelayResponse.Merge(m, src)
}
func (m *PurgeWorkerRelayResponse) XXX_Size() int {
	return m.Size()
}
func (m *PurgeWorkerRelayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PurgeWorkerRelayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PurgeWorkerRelayResponse proto.InternalMessageInfo

func (m *PurgeWorkerRelayResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *PurgeWorkerRelayResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PurgeWorkerRelayResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type CheckTaskRequest struct {
	Task string `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
}

func (m *CheckTaskRequest) Reset()         { *m = CheckTaskRequest{} }
func (m *CheckTaskRequest) String() string { return proto.CompactTextString(m) }
func (*CheckTaskRequest) ProtoMessage()    {}
func (*CheckTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{27}
}
func (m *CheckTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckTaskRequest.Merge(m, src)
}
func (m *CheckTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckTaskRequest proto.InternalMessageInfo

func (m *CheckTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

type CheckTaskResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *CheckTaskResponse) Reset()         { *m = CheckTaskResponse{} }
func (m *CheckTaskResponse) String() string { return proto.CompactTextString(m) }
func (*CheckTaskResponse) ProtoMessage()    {}
func (*CheckTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{28}
}
func (m *CheckTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckTaskResponse.Merge(m, src)
}
func (m *CheckTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckTaskResponse proto.InternalMessageInfo

func (m *CheckTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *CheckTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type OperateSourceRequest struct {
	Op     SourceOp `protobuf:"varint,1,opt,name=op,proto3,enum=pb.SourceOp" json:"op,omitempty"`
	Config string   `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *OperateSourceRequest) Reset()         { *m = OperateSourceRequest{} }
func (m *OperateSourceRequest) String() string { return proto.CompactTextString(m) }
func (*OperateSourceRequest) ProtoMessage()    {}
func (*OperateSourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{29}
}
func (m *OperateSourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateSourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateSourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateSourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateSourceRequest.Merge(m, src)
}
func (m *OperateSourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateSourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateSourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateSourceRequest proto.InternalMessageInfo

func (m *OperateSourceRequest) GetOp() SourceOp {
	if m != nil {
		return m.Op
	}
	return SourceOp_InvalidSourceOp
}

func (m *OperateSourceRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

type OperateSourceResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateSourceResponse) Reset()         { *m = OperateSourceResponse{} }
func (m *OperateSourceResponse) String() string { return proto.CompactTextString(m) }
func (*OperateSourceResponse) ProtoMessage()    {}
func (*OperateSourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{30}
}
func (m *OperateSourceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateSourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateSourceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateSourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateSourceResponse.Merge(m, src)
}
func (m *OperateSourceResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateSourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateSourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateSourceResponse proto.InternalMessageInfo

func (m *OperateSourceResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateSourceResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateSourceResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type RegisterWorkerRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *RegisterWorkerRequest) Reset()         { *m = RegisterWorkerRequest{} }
func (m *RegisterWorkerRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterWorkerRequest) ProtoMessage()    {}
func (*RegisterWorkerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{31}
}
func (m *RegisterWorkerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWorkerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWorkerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWorkerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWorkerRequest.Merge(m, src)
}
func (m *RegisterWorkerRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWorkerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWorkerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWorkerRequest proto.InternalMessageInfo

func (m *RegisterWorkerRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegisterWorkerRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type RegisterWorkerResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *RegisterWorkerResponse) Reset()         { *m = RegisterWorkerResponse{} }
func (m *RegisterWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterWorkerResponse) ProtoMessage()    {}
func (*RegisterWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{32}
}
func (m *RegisterWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWorkerResponse.Merge(m, src)
}
func (m *RegisterWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWorkerResponse proto.InternalMessageInfo

func (m *RegisterWorkerResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *RegisterWorkerResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type OfflineWorkerRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *OfflineWorkerRequest) Reset()         { *m = OfflineWorkerRequest{} }
func (m *OfflineWorkerRequest) String() string { return proto.CompactTextString(m) }
func (*OfflineWorkerRequest) ProtoMessage()    {}
func (*OfflineWorkerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{33}
}
func (m *OfflineWorkerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OfflineWorkerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OfflineWorkerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OfflineWorkerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OfflineWorkerRequest.Merge(m, src)
}
func (m *OfflineWorkerRequest) XXX_Size() int {
	return m.Size()
}
func (m *OfflineWorkerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OfflineWorkerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OfflineWorkerRequest proto.InternalMessageInfo

func (m *OfflineWorkerRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type OfflineWorkerResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *OfflineWorkerResponse) Reset()         { *m = OfflineWorkerResponse{} }
func (m *OfflineWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*OfflineWorkerResponse) ProtoMessage()    {}
func (*OfflineWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{34}
}
func (m *OfflineWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OfflineWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OfflineWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OfflineWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OfflineWorkerResponse.Merge(m, src)
}
func (m *OfflineWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *OfflineWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OfflineWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OfflineWorkerResponse proto.InternalMessageInfo

func (m *OfflineWorkerResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OfflineWorkerResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type MasterInfo struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MemberID   uint64   `protobuf:"varint,2,opt,name=memberID,proto3" json:"memberID,omitempty"`
	Alive      bool     `protobuf:"varint,3,opt,name=alive,proto3" json:"alive,omitempty"`
	PeerURLs   []string `protobuf:"bytes,4,rep,name=peerURLs,proto3" json:"peerURLs,omitempty"`
	ClientURLs []string `protobuf:"bytes,5,rep,name=clientURLs,proto3" json:"clientURLs,omitempty"`
}

func (m *MasterInfo) Reset()         { *m = MasterInfo{} }
func (m *MasterInfo) String() string { return proto.CompactTextString(m) }
func (*MasterInfo) ProtoMessage()    {}
func (*MasterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{35}
}
func (m *MasterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MasterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MasterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MasterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MasterInfo.Merge(m, src)
}
func (m *MasterInfo) XXX_Size() int {
	return m.Size()
}
func (m *MasterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MasterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MasterInfo proto.InternalMessageInfo

func (m *MasterInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MasterInfo) GetMemberID() uint64 {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *MasterInfo) GetAlive() bool {
	if m != nil {
		return m.Alive
	}
	return false
}

func (m *MasterInfo) GetPeerURLs() []string {
	if m != nil {
		return m.PeerURLs
	}
	return nil
}

func (m *MasterInfo) GetClientURLs() []string {
	if m != nil {
		return m.ClientURLs
	}
	return nil
}

type WorkerInfo struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Addr   string `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	Stage  string `protobuf:"bytes,3,opt,name=stage,proto3" json:"stage,omitempty"`
	Source string `protobuf:"bytes,4,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *WorkerInfo) Reset()         { *m = WorkerInfo{} }
func (m *WorkerInfo) String() string { return proto.CompactTextString(m) }
func (*WorkerInfo) ProtoMessage()    {}
func (*WorkerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{36}
}
func (m *WorkerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerInfo.Merge(m, src)
}
func (m *WorkerInfo) XXX_Size() int {
	return m.Size()
}
func (m *WorkerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerInfo proto.InternalMessageInfo

func (m *WorkerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WorkerInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *WorkerInfo) GetStage() string {
	if m != nil {
		return m.Stage
	}
	return ""
}

func (m *WorkerInfo) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type ListLeaderMember struct {
	Msg  string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Addr string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *ListLeaderMember) Reset()         { *m = ListLeaderMember{} }
func (m *ListLeaderMember) String() string { return proto.CompactTextString(m) }
func (*ListLeaderMember) ProtoMessage()    {}
func (*ListLeaderMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{37}
}
func (m *ListLeaderMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListLeaderMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListLeaderMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListLeaderMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListLeaderMember.Merge(m, src)
}
func (m *ListLeaderMember) XXX_Size() int {
	return m.Size()
}
func (m *ListLeaderMember) XXX_DiscardUnknown() {
	xxx_messageInfo_ListLeaderMember.DiscardUnknown(m)
}

var xxx_messageInfo_ListLeaderMember proto.InternalMessageInfo

func (m *ListLeaderMember) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ListLeaderMember) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListLeaderMember) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type ListMasterMember struct {
	Msg     string        `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Masters []*MasterInfo `protobuf:"bytes,2,rep,name=masters,proto3" json:"masters,omitempty"`
}

func (m *ListMasterMember) Reset()         { *m = ListMasterMember{} }
func (m *ListMasterMember) String() string { return proto.CompactTextString(m) }
func (*ListMasterMember) ProtoMessage()    {}
func (*ListMasterMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{38}
}
func (m *ListMasterMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMasterMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMasterMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMasterMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMasterMember.Merge(m, src)
}
func (m *ListMasterMember) XXX_Size() int {
	return m.Size()
}
func (m *ListMasterMember) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMasterMember.DiscardUnknown(m)
}

var xxx_messageInfo_ListMasterMember proto.InternalMessageInfo

func (m *ListMasterMember) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ListMasterMember) GetMasters() []*MasterInfo {
	if m != nil {
		return m.Masters
	}
	return nil
}

type ListWorkerMember struct {
	Msg     string        `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers []*WorkerInfo `protobuf:"bytes,2,rep,name=workers,proto3" json:"workers,omitempty"`
}

func (m *ListWorkerMember) Reset()         { *m = ListWorkerMember{} }
func (m *ListWorkerMember) String() string { return proto.CompactTextString(m) }
func (*ListWorkerMember) ProtoMessage()    {}
func (*ListWorkerMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{39}
}
func (m *ListWorkerMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListWorkerMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListWorkerMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListWorkerMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListWorkerMember.Merge(m, src)
}
func (m *ListWorkerMember) XXX_Size() int {
	return m.Size()
}
func (m *ListWorkerMember) XXX_DiscardUnknown() {
	xxx_messageInfo_ListWorkerMember.DiscardUnknown(m)
}

var xxx_messageInfo_ListWorkerMember proto.InternalMessageInfo

func (m *ListWorkerMember) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ListWorkerMember) GetWorkers() []*WorkerInfo {
	if m != nil {
		return m.Workers
	}
	return nil
}

type Members struct {
	// Types that are valid to be assigned to Member:
	//	*Members_Leader
	//	*Members_Master
	//	*Members_Worker
	Member isMembers_Member `protobuf_oneof:"member"`
}

func (m *Members) Reset()         { *m = Members{} }
func (m *Members) String() string { return proto.CompactTextString(m) }
func (*Members) ProtoMessage()    {}
func (*Members) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{40}
}
func (m *Members) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Members) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Members.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Members) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Members.Merge(m, src)
}
func (m *Members) XXX_Size() int {
	return m.Size()
}
func (m *Members) XXX_DiscardUnknown() {
	xxx_messageInfo_Members.DiscardUnknown(m)
}

var xxx_messageInfo_Members proto.InternalMessageInfo

type isMembers_Member interface {
	isMembers_Member()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Members_Leader struct {
	Leader *ListLeaderMember `protobuf:"bytes,1,opt,name=leader,proto3,oneof" json:"leader,omitempty"`
}
type Members_Master struct {
	Master *ListMasterMember `protobuf:"bytes,2,opt,name=master,proto3,oneof" json:"master,omitempty"`
}
type Members_Worker struct {
	Worker *ListWorkerMember `protobuf:"bytes,3,opt,name=worker,proto3,oneof" json:"worker,omitempty"`
}

func (*Members_Leader) isMembers_Member() {}
func (*Members_Master) isMembers_Member() {}
func (*Members_Worker) isMembers_Member() {}

func (m *Members) GetMember() isMembers_Member {
	if m != nil {
		return m.Member
	}
	return nil
}

func (m *Members) GetLeader() *ListLeaderMember {
	if x, ok := m.GetMember().(*Members_Leader); ok {
		return x.Leader
	}
	return nil
}

func (m *Members) GetMaster() *ListMasterMember {
	if x, ok := m.GetMember().(*Members_Master); ok {
		return x.Master
	}
	return nil
}

func (m *Members) GetWorker() *ListWorkerMember {
	if x, ok := m.GetMember().(*Members_Worker); ok {
		return x.Worker
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Members) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Members_Leader)(nil),
		(*Members_Master)(nil),
		(*Members_Worker)(nil),
	}
}

type ListMemberRequest struct {
	Leader bool     `protobuf:"varint,1,opt,name=leader,proto3" json:"leader,omitempty"`
	Master bool     `protobuf:"varint,2,opt,name=master,proto3" json:"master,omitempty"`
	Worker bool     `protobuf:"varint,3,opt,name=worker,proto3" json:"worker,omitempty"`
	Names  []string `protobuf:"bytes,4,rep,name=names,proto3" json:"names,omitempty"`
}

func (m *ListMemberRequest) Reset()         { *m = ListMemberRequest{} }
func (m *ListMemberRequest) String() string { return proto.CompactTextString(m) }
func (*ListMemberRequest) ProtoMessage()    {}
func (*ListMemberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{41}
}
func (m *ListMemberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMemberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMemberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMemberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMemberRequest.Merge(m, src)
}
func (m *ListMemberRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListMemberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMemberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListMemberRequest proto.InternalMessageInfo

func (m *ListMemberRequest) GetLeader() bool {
	if m != nil {
		return m.Leader
	}
	return false
}

func (m *ListMemberRequest) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *ListMemberRequest) GetWorker() bool {
	if m != nil {
		return m.Worker
	}
	return false
}

func (m *ListMemberRequest) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type ListMemberResponse struct {
	Result  bool       `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Members []*Members `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *ListMemberResponse) Reset()         { *m = ListMemberResponse{} }
func (m *ListMemberResponse) String() string { return proto.CompactTextString(m) }
func (*ListMemberResponse) ProtoMessage()    {}
func (*ListMemberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{42}
}
func (m *ListMemberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMemberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMemberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMemberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMemberResponse.Merge(m, src)
}
func (m *ListMemberResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListMemberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMemberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMemberResponse proto.InternalMessageInfo

func (m *ListMemberResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ListMemberResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ListMemberResponse) GetMembers() []*Members {
	if m != nil {
		return m.Members
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.SourceOp", SourceOp_name, SourceOp_value)
	proto.RegisterType((*MigrateWorkerRelayRequest)(nil), "pb.MigrateWorkerRelayRequest")
	proto.RegisterType((*UpdateWorkerRelayConfigRequest)(nil), "pb.UpdateWorkerRelayConfigRequest")
	proto.RegisterType((*StartTaskRequest)(nil), "pb.StartTaskRequest")
	proto.RegisterType((*StartTaskResponse)(nil), "pb.StartTaskResponse")
	proto.RegisterType((*UpdateMasterConfigRequest)(nil), "pb.UpdateMasterConfigRequest")
	proto.RegisterType((*UpdateMasterConfigResponse)(nil), "pb.UpdateMasterConfigResponse")
	proto.RegisterType((*OperateTaskRequest)(nil), "pb.OperateTaskRequest")
	proto.RegisterType((*OperateTaskResponse)(nil), "pb.OperateTaskResponse")
	proto.RegisterType((*UpdateTaskRequest)(nil), "pb.UpdateTaskRequest")
	proto.RegisterType((*UpdateTaskResponse)(nil), "pb.UpdateTaskResponse")
	proto.RegisterType((*QueryStatusListRequest)(nil), "pb.QueryStatusListRequest")
	proto.RegisterType((*QueryStatusListResponse)(nil), "pb.QueryStatusListResponse")
	proto.RegisterType((*QueryErrorListRequest)(nil), "pb.QueryErrorListRequest")
	proto.RegisterType((*QueryErrorListResponse)(nil), "pb.QueryErrorListResponse")
	proto.RegisterType((*ShowDDLLocksRequest)(nil), "pb.ShowDDLLocksRequest")
	proto.RegisterType((*DDLLock)(nil), "pb.DDLLock")
	proto.RegisterType((*ShowDDLLocksResponse)(nil), "pb.ShowDDLLocksResponse")
	proto.RegisterType((*UnlockDDLLockRequest)(nil), "pb.UnlockDDLLockRequest")
	proto.RegisterType((*UnlockDDLLockResponse)(nil), "pb.UnlockDDLLockResponse")
	proto.RegisterType((*SwitchWorkerRelayMasterRequest)(nil), "pb.SwitchWorkerRelayMasterRequest")
	proto.RegisterType((*SwitchWorkerRelayMasterResponse)(nil), "pb.SwitchWorkerRelayMasterResponse")
	proto.RegisterType((*OperateWorkerRelayRequest)(nil), "pb.OperateWorkerRelayRequest")
	proto.RegisterType((*OperateWorkerRelayResponse)(nil), "pb.OperateWorkerRelayResponse")
	proto.RegisterType((*HandleSQLsRequest)(nil), "pb.HandleSQLsRequest")
	proto.RegisterType((*HandleSQLsResponse)(nil), "pb.HandleSQLsResponse")
	proto.RegisterType((*PurgeWorkerRelayRequest)(nil), "pb.PurgeWorkerRelayRequest")
	proto.RegisterType((*PurgeWorkerRelayResponse)(nil), "pb.PurgeWorkerRelayResponse")
	proto.RegisterType((*CheckTaskRequest)(nil), "pb.CheckTaskRequest")
	proto.RegisterType((*CheckTaskResponse)(nil), "pb.CheckTaskResponse")
	proto.RegisterType((*OperateSourceRequest)(nil), "pb.OperateSourceRequest")
	proto.RegisterType((*OperateSourceResponse)(nil), "pb.OperateSourceResponse")
	proto.RegisterType((*RegisterWorkerRequest)(nil), "pb.RegisterWorkerRequest")
	proto.RegisterType((*RegisterWorkerResponse)(nil), "pb.RegisterWorkerResponse")
	proto.RegisterType((*OfflineWorkerRequest)(nil), "pb.OfflineWorkerRequest")
	proto.RegisterType((*OfflineWorkerResponse)(nil), "pb.OfflineWorkerResponse")
	proto.RegisterType((*MasterInfo)(nil), "pb.MasterInfo")
	proto.RegisterType((*WorkerInfo)(nil), "pb.WorkerInfo")
	proto.RegisterType((*ListLeaderMember)(nil), "pb.ListLeaderMember")
	proto.RegisterType((*ListMasterMember)(nil), "pb.ListMasterMember")
	proto.RegisterType((*ListWorkerMember)(nil), "pb.ListWorkerMember")
	proto.RegisterType((*Members)(nil), "pb.Members")
	proto.RegisterType((*ListMemberRequest)(nil), "pb.ListMemberRequest")
	proto.RegisterType((*ListMemberResponse)(nil), "pb.ListMemberResponse")
}

func init() { proto.RegisterFile("dmmaster.proto", fileDescriptor_f9bef11f2a341f03) }

var fileDescriptor_f9bef11f2a341f03 = []byte{
	// 1715 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x5f, 0x4f, 0x1b, 0xc7,
	0x16, 0xf7, 0xda, 0x60, 0xcc, 0x31, 0x10, 0x33, 0x01, 0x63, 0x16, 0xe2, 0x90, 0xb9, 0x37, 0x11,
	0xe2, 0x01, 0x6e, 0xc8, 0x5b, 0xa4, 0x3c, 0x04, 0x4c, 0x14, 0x24, 0x13, 0xc8, 0xfa, 0xa2, 0xab,
	0xbc, 0x5c, 0x75, 0xf1, 0x8e, 0xcd, 0x8a, 0xf5, 0xee, 0xb2, 0xbb, 0x86, 0xa2, 0xaa, 0xaa, 0xd4,
	0x0f, 0xd0, 0x56, 0xea, 0x43, 0x1e, 0xfb, 0xd0, 0xaf, 0xd1, 0x0f, 0x90, 0xc7, 0x48, 0x7d, 0xe9,
	0x63, 0x95, 0xf4, 0x83, 0x54, 0xf3, 0x67, 0x77, 0x67, 0xff, 0xd8, 0x89, 0x23, 0x95, 0xb7, 0x39,
	0x67, 0x66, 0xce, 0xf9, 0xcd, 0x99, 0x33, 0xe7, 0xcf, 0xc0, 0x82, 0x31, 0x18, 0xe8, 0x7e, 0x40,
	0xbc, 0x6d, 0xd7, 0x73, 0x02, 0x07, 0x15, 0xdd, 0x33, 0x75, 0xc1, 0x18, 0x5c, 0x3b, 0xde, 0x45,
	0xc8, 0x53, 0xd7, 0xfb, 0x8e, 0xd3, 0xb7, 0xc8, 0x8e, 0xee, 0x9a, 0x3b, 0xba, 0x6d, 0x3b, 0x81,
	0x1e, 0x98, 0x8e, 0xed, 0xf3, 0x59, 0x7c, 0x09, 0xab, 0x47, 0x66, 0xdf, 0xd3, 0x03, 0xf2, 0x3f,
	0xb6, 0x49, 0x23, 0x96, 0x7e, 0xa3, 0x91, 0xcb, 0x21, 0xf1, 0x03, 0xd4, 0x04, 0xd8, 0x33, 0x6d,
	0xcb, 0xe9, 0xbf, 0xd2, 0x07, 0xa4, 0xa1, 0x6c, 0x28, 0x9b, 0xb3, 0x9a, 0xc4, 0x41, 0xeb, 0x30,
	0xcb, 0xa9, 0x13, 0xc7, 0x6f, 0x14, 0x37, 0x94, 0xcd, 0x79, 0x2d, 0x66, 0xa0, 0x3a, 0x94, 0x7d,
	0x67, 0xe8, 0x75, 0x49, 0xa3, 0xc4, 0x76, 0x0a, 0x0a, 0x9f, 0x40, 0xf3, 0xd4, 0x35, 0x92, 0x1a,
	0xf7, 0x1d, 0xbb, 0x67, 0xf6, 0x43, 0xbd, 0x75, 0x28, 0x77, 0x19, 0x43, 0xe8, 0x14, 0x94, 0x24,
	0xb1, 0x98, 0x90, 0xf8, 0x15, 0xd4, 0x3a, 0x81, 0xee, 0x05, 0xff, 0xd5, 0xfd, 0x8b, 0x50, 0x06,
	0x82, 0xa9, 0x40, 0xf7, 0x2f, 0x84, 0x04, 0x36, 0x46, 0x0d, 0x98, 0xe1, 0x3b, 0x28, 0xda, 0xd2,
	0xe6, 0xac, 0x16, 0x92, 0xf4, 0xa4, 0x1e, 0x19, 0x38, 0x57, 0xe4, 0x88, 0x04, 0x3a, 0xc3, 0x5b,
	0xd1, 0x24, 0x0e, 0xbe, 0x84, 0x45, 0x49, 0x83, 0xef, 0x3a, 0xb6, 0x4f, 0x28, 0x1c, 0x8f, 0xf8,
	0x43, 0x2b, 0x60, 0x4a, 0x2a, 0x9a, 0xa0, 0x50, 0x0d, 0x4a, 0x03, 0xbf, 0x2f, 0x30, 0xd2, 0x21,
	0xda, 0x8d, 0x15, 0x97, 0x36, 0x4a, 0x9b, 0xd5, 0xdd, 0xc6, 0xb6, 0x7b, 0xb6, 0xbd, 0xef, 0x0c,
	0x06, 0x8e, 0x1d, 0x5a, 0x81, 0x0b, 0x8d, 0x20, 0xe1, 0x27, 0xb0, 0xca, 0xcd, 0x74, 0xc4, 0x6e,
	0xf8, 0xb3, 0x2c, 0x84, 0x6f, 0x40, 0xcd, 0xdb, 0x34, 0x31, 0xe0, 0xc7, 0x69, 0xc0, 0x2b, 0x14,
	0xf0, 0xeb, 0x21, 0xf1, 0x6e, 0x3a, 0x81, 0x1e, 0x0c, 0xfd, 0x2c, 0xde, 0xff, 0x03, 0x3a, 0x76,
	0x09, 0xf5, 0x24, 0xf9, 0x1a, 0x54, 0x28, 0x3a, 0x2e, 0x53, 0xb7, 0xb0, 0x0b, 0x54, 0x06, 0x9d,
	0x3c, 0x76, 0xb5, 0xa2, 0xe3, 0xd2, 0x2b, 0xb2, 0xa9, 0x63, 0x71, 0xbd, 0x6c, 0x2c, 0x5f, 0x51,
	0x29, 0x71, 0x45, 0xf8, 0x47, 0x05, 0xee, 0x26, 0x14, 0x88, 0x43, 0x8d, 0xd3, 0x10, 0x1f, 0xb8,
	0x98, 0x77, 0xe0, 0x52, 0xee, 0x0d, 0x4d, 0x7d, 0xee, 0x0d, 0x3d, 0x87, 0x45, 0x6e, 0xec, 0x2f,
	0xf6, 0x3b, 0xec, 0x01, 0x92, 0x45, 0xdc, 0x8a, 0x63, 0xbd, 0x80, 0xba, 0x74, 0x91, 0x6d, 0xd3,
	0x0f, 0x24, 0xec, 0x76, 0xfc, 0xd2, 0x33, 0x17, 0x92, 0xc2, 0x7e, 0x05, 0x2b, 0x19, 0x39, 0xb7,
	0xe1, 0x68, 0x07, 0xb0, 0xcc, 0xe6, 0x0f, 0x3c, 0xcf, 0xf1, 0xbe, 0x1c, 0x7e, 0x20, 0xcc, 0x20,
	0x89, 0x99, 0x18, 0xfd, 0x7f, 0xd2, 0xe8, 0xeb, 0x11, 0x7a, 0x26, 0x36, 0x0b, 0x7e, 0x1f, 0xee,
	0x76, 0xce, 0x9d, 0xeb, 0x56, 0xab, 0xdd, 0x76, 0xba, 0x17, 0xfe, 0x97, 0x79, 0xcd, 0x2f, 0x0a,
	0xcc, 0x08, 0x09, 0x68, 0x01, 0x8a, 0x87, 0x2d, 0xb1, 0xaf, 0x78, 0xd8, 0x8a, 0x24, 0x15, 0x25,
	0x49, 0x08, 0xa6, 0x06, 0x8e, 0x11, 0xc6, 0x61, 0x36, 0x46, 0x4b, 0x30, 0xed, 0x5c, 0xdb, 0xc4,
	0x6b, 0x4c, 0x31, 0x26, 0x27, 0xe8, 0xca, 0x56, 0xab, 0xed, 0x37, 0xa6, 0x99, 0x42, 0x36, 0x66,
	0x51, 0xf7, 0xc6, 0xee, 0x12, 0xa3, 0x51, 0x66, 0x5c, 0x41, 0x21, 0x15, 0x2a, 0x43, 0x5b, 0xcc,
	0xcc, 0xb0, 0x99, 0x88, 0xc6, 0x5d, 0x58, 0x4a, 0x1e, 0x73, 0x62, 0xd3, 0x3e, 0x80, 0x69, 0x8b,
	0x6e, 0x15, 0x86, 0xad, 0x52, 0xc3, 0x0a, 0x71, 0x1a, 0x9f, 0xc1, 0x16, 0x2c, 0x9d, 0xda, 0x74,
	0x18, 0xf2, 0x85, 0x31, 0xd3, 0x26, 0xc1, 0x30, 0xe7, 0x11, 0xd7, 0xd2, 0xbb, 0xe4, 0x98, 0x9d,
	0x98, 0x6b, 0x49, 0xf0, 0xd0, 0x06, 0x54, 0x7b, 0x8e, 0xd7, 0x25, 0x1a, 0x8b, 0xf9, 0x22, 0x03,
	0xc8, 0x2c, 0xfc, 0x1c, 0x96, 0x53, 0xda, 0x26, 0x3d, 0x13, 0x7e, 0x0a, 0xcd, 0xce, 0xb5, 0x19,
	0x74, 0xcf, 0xa5, 0xcc, 0xc7, 0x03, 0x75, 0x08, 0x5d, 0xba, 0x73, 0x25, 0x79, 0xe7, 0xdf, 0xc1,
	0xfd, 0x91, 0x7b, 0x6f, 0x25, 0x6c, 0x68, 0xb0, 0x2a, 0xc2, 0x6f, 0x4e, 0xa5, 0xb0, 0x26, 0x05,
	0x61, 0x76, 0x55, 0x6c, 0x56, 0x44, 0xe1, 0xd1, 0x8e, 0xfc, 0x56, 0x01, 0x35, 0x4f, 0xa8, 0x38,
	0xd0, 0x58, 0xa9, 0xff, 0x6c, 0x6c, 0x7f, 0xa7, 0xc0, 0xe2, 0x4b, 0xdd, 0x36, 0x2c, 0xd2, 0x79,
	0xdd, 0xf6, 0xc7, 0x45, 0x98, 0x55, 0x06, 0xb2, 0xc8, 0x40, 0xce, 0x52, 0xc1, 0x9d, 0xd7, 0xed,
	0x38, 0xc1, 0xe9, 0x5e, 0x3f, 0xcc, 0x64, 0x6c, 0x4c, 0x6b, 0xa6, 0xb3, 0xa8, 0x66, 0xe2, 0x6f,
	0x2f, 0x66, 0x48, 0x15, 0xce, 0xb4, 0x5c, 0xe1, 0xd0, 0xfa, 0xc4, 0xbf, 0xb4, 0x4e, 0xf4, 0x20,
	0x20, 0x9e, 0xdd, 0x28, 0xf3, 0x4a, 0x2c, 0xe6, 0xd0, 0xb7, 0xe8, 0x9f, 0xeb, 0x9e, 0x61, 0xda,
	0xfd, 0xc6, 0x0c, 0x33, 0x47, 0x44, 0xd3, 0x1c, 0x23, 0x9f, 0xe4, 0x56, 0x9c, 0xe5, 0xad, 0x02,
	0x2b, 0x27, 0x43, 0xaf, 0x9f, 0xe7, 0x2b, 0x23, 0x7d, 0x9c, 0x9e, 0xc2, 0xb4, 0xf5, 0x6e, 0x60,
	0x5e, 0x11, 0x71, 0xa9, 0x11, 0xcd, 0xe2, 0x9a, 0x39, 0xe0, 0x2f, 0xb3, 0xa4, 0xb1, 0x31, 0x5d,
	0xdf, 0x33, 0x2d, 0xc2, 0xae, 0x84, 0x9b, 0x32, 0xa2, 0x99, 0x25, 0x87, 0x67, 0x2d, 0xd3, 0x8b,
	0x2c, 0xc9, 0x28, 0xfc, 0x35, 0x34, 0xb2, 0xc0, 0x6e, 0xc5, 0x26, 0x8f, 0xa0, 0xb6, 0x7f, 0x4e,
	0xba, 0x17, 0x9f, 0xa8, 0x16, 0xf0, 0x33, 0x58, 0x94, 0xd6, 0x4d, 0x1c, 0x64, 0xda, 0xb0, 0x24,
	0x9e, 0x54, 0x87, 0x29, 0x0e, 0x55, 0xad, 0x4b, 0x8f, 0x69, 0x8e, 0xf9, 0x29, 0x9b, 0x8e, 0x5f,
	0x93, 0x28, 0x28, 0x8b, 0x89, 0x82, 0x72, 0x08, 0xcb, 0x29, 0x69, 0xb7, 0x62, 0xab, 0x03, 0x58,
	0xd6, 0x48, 0xdf, 0xa4, 0xe1, 0x2d, 0x5c, 0x32, 0x36, 0xc7, 0xeb, 0x86, 0xe1, 0x11, 0xdf, 0x17,
	0x6a, 0x43, 0x12, 0xef, 0x41, 0x3d, 0x2d, 0x66, 0x62, 0x7b, 0x6e, 0xc1, 0xd2, 0x71, 0xaf, 0x67,
	0x99, 0x36, 0xf9, 0x24, 0x12, 0x9a, 0x23, 0x52, 0x6b, 0x27, 0x56, 0xf7, 0x83, 0x02, 0xc0, 0xe3,
	0xfa, 0xa1, 0xdd, 0x73, 0x72, 0xcf, 0xab, 0x42, 0x65, 0x40, 0x06, 0x67, 0xc4, 0x3b, 0x6c, 0xb1,
	0x9d, 0x53, 0x5a, 0x44, 0xd3, 0xb4, 0xae, 0x5b, 0x66, 0x94, 0xc1, 0x38, 0x41, 0x77, 0xb8, 0x84,
	0x78, 0xa7, 0x5a, 0x9b, 0x87, 0xc0, 0x59, 0x2d, 0xa2, 0x69, 0x68, 0xe9, 0x5a, 0x26, 0xb1, 0x03,
	0x36, 0xcb, 0x13, 0xbf, 0xc4, 0xc1, 0x67, 0x00, 0xfc, 0x30, 0x23, 0xf1, 0xd0, 0x30, 0x67, 0x18,
	0x61, 0x5e, 0x65, 0x63, 0x8a, 0xc3, 0x0f, 0xf4, 0x7e, 0x58, 0x73, 0x70, 0x42, 0x0a, 0x6f, 0x53,
	0x89, 0x06, 0xae, 0x0d, 0x35, 0x5a, 0x81, 0xb5, 0x89, 0x6e, 0x10, 0xef, 0x88, 0x9d, 0x25, 0x34,
	0x8d, 0x12, 0x3b, 0x52, 0x5e, 0xbf, 0x10, 0xea, 0x2e, 0xc5, 0xba, 0xf1, 0x2b, 0x2e, 0x8d, 0x5b,
	0x71, 0xa4, 0xb4, 0x4d, 0x98, 0xe1, 0xbd, 0x33, 0xcf, 0x4a, 0xd5, 0xdd, 0x05, 0xea, 0x96, 0xb1,
	0xe9, 0xb5, 0x70, 0x3a, 0x94, 0xc7, 0xad, 0x30, 0x4e, 0x1e, 0xef, 0xbb, 0x13, 0xf2, 0x62, 0xd3,
	0x69, 0xe1, 0x34, 0xfe, 0x55, 0x81, 0x19, 0x2e, 0xc6, 0x47, 0xdb, 0x50, 0xb6, 0xd8, 0xa9, 0x99,
	0xa8, 0xea, 0xee, 0x12, 0xdd, 0x94, 0xb6, 0xc5, 0xcb, 0x82, 0x26, 0x56, 0xd1, 0xf5, 0x1c, 0x16,
	0xb3, 0x82, 0xb4, 0x5e, 0x3e, 0x2d, 0x5d, 0xcf, 0x57, 0xd1, 0xf5, 0x5c, 0x2d, 0xb3, 0x90, 0xb4,
	0x5e, 0x3e, 0x0d, 0x5d, 0xcf, 0x57, 0xed, 0x55, 0xa0, 0xcc, 0x7d, 0x89, 0xb6, 0xbc, 0x4c, 0x2e,
	0xa3, 0xa4, 0xbe, 0x53, 0x82, 0x5b, 0x89, 0x60, 0xd5, 0x13, 0xb0, 0x2a, 0x91, 0xfa, 0x7a, 0x42,
	0x7d, 0x25, 0x54, 0x43, 0xdd, 0x83, 0x5e, 0x5f, 0xe8, 0x8d, 0x9c, 0xc0, 0x04, 0x90, 0xac, 0x72,
	0xe2, 0x48, 0xf3, 0x10, 0x66, 0x38, 0xf8, 0x44, 0xd5, 0x28, 0x4c, 0xad, 0x85, 0x73, 0x5b, 0x1a,
	0x54, 0xc2, 0xd8, 0x87, 0xee, 0xc2, 0x9d, 0x43, 0xfb, 0x4a, 0xb7, 0x4c, 0x23, 0x64, 0xd5, 0x0a,
	0xe8, 0x0e, 0x54, 0x59, 0xb7, 0xcf, 0x59, 0x35, 0x05, 0xd5, 0x60, 0x8e, 0xb7, 0x69, 0x82, 0x53,
	0x44, 0x0b, 0x00, 0x9d, 0xc0, 0x71, 0x05, 0x5d, 0xda, 0xfd, 0x6d, 0x0e, 0xca, 0xfc, 0x0a, 0xd0,
	0x1b, 0x98, 0x8d, 0xfe, 0x0a, 0x10, 0xb3, 0x77, 0xfa, 0x73, 0x42, 0x5d, 0x4e, 0x71, 0xf9, 0x49,
	0xf1, 0xfd, 0xef, 0x7f, 0xff, 0xeb, 0xe7, 0xe2, 0x2a, 0x5e, 0xda, 0xd1, 0x5d, 0xd3, 0xdf, 0xb9,
	0x7a, 0xac, 0x5b, 0xee, 0xb9, 0xfe, 0x78, 0x87, 0xa6, 0x05, 0xff, 0xa9, 0xb2, 0x85, 0x7a, 0x50,
	0x95, 0x5a, 0x60, 0xc4, 0xba, 0x8d, 0x6c, 0xd3, 0xad, 0xae, 0x64, 0xf8, 0x42, 0xc1, 0x23, 0xa6,
	0x60, 0x43, 0x5d, 0xcb, 0x53, 0xb0, 0xf3, 0x0d, 0xbd, 0x85, 0x6f, 0xa9, 0x9e, 0x67, 0x00, 0x71,
	0x5b, 0x8a, 0x18, 0xda, 0x4c, 0xa7, 0xab, 0xd6, 0xd3, 0x6c, 0xa1, 0xa4, 0x80, 0x2c, 0xa8, 0x4a,
	0x1d, 0x1c, 0x52, 0x53, 0x2d, 0x9d, 0xd4, 0xb3, 0xa9, 0x6b, 0xb9, 0x73, 0x42, 0xd2, 0xbf, 0x19,
	0xdc, 0x26, 0x5a, 0x4f, 0xc1, 0xf5, 0xd9, 0x52, 0x81, 0x17, 0x1d, 0x00, 0xc4, 0x1d, 0x17, 0x5a,
	0x4d, 0x76, 0x60, 0xb2, 0x2e, 0x35, 0x6f, 0x2a, 0x02, 0xbd, 0x0f, 0x73, 0x72, 0xcb, 0x82, 0x98,
	0x11, 0x73, 0x7a, 0x35, 0xb5, 0x91, 0x9d, 0x88, 0x84, 0xbc, 0x80, 0xf9, 0x44, 0x93, 0x80, 0xd8,
	0xe2, 0xbc, 0x2e, 0x45, 0x5d, 0xcd, 0x99, 0x89, 0xe4, 0x9c, 0x86, 0xff, 0x02, 0xf2, 0x3f, 0x0e,
	0xba, 0x17, 0x5b, 0x3c, 0xe7, 0x53, 0x48, 0x6d, 0x8e, 0x9a, 0x8e, 0xc4, 0xbe, 0x81, 0x95, 0x11,
	0x5f, 0x6f, 0x08, 0xc7, 0x9b, 0x47, 0xfd, 0xcb, 0xa9, 0x23, 0x13, 0x37, 0x2e, 0x50, 0x97, 0x89,
	0xab, 0x4c, 0xee, 0x32, 0x99, 0xfa, 0x99, 0xbb, 0x4c, 0xb6, 0x18, 0xc5, 0x05, 0x64, 0xc0, 0xca,
	0x88, 0xf6, 0x86, 0x23, 0x1b, 0xdf, 0x37, 0xa9, 0xff, 0x1a, 0xbb, 0x46, 0x3a, 0x7f, 0x3d, 0xdb,
	0x6e, 0x30, 0x1f, 0xbf, 0x27, 0x3d, 0x99, 0x6c, 0xcd, 0xca, 0x4d, 0x3b, 0xba, 0x53, 0xc1, 0x05,
	0x74, 0x0c, 0xb5, 0x74, 0x5d, 0x89, 0x98, 0x73, 0x8f, 0x28, 0x83, 0xd5, 0xf5, 0xfc, 0x49, 0x49,
	0x20, 0xca, 0xfe, 0xcc, 0x72, 0x9c, 0x23, 0x7f, 0x6c, 0xc7, 0xde, 0xd0, 0x53, 0x98, 0x8d, 0xea,
	0x4a, 0x1e, 0x97, 0xd2, 0xe5, 0x28, 0x8f, 0x4b, 0x99, 0xe2, 0x13, 0x17, 0x50, 0x1f, 0xe6, 0x13,
	0x65, 0x20, 0xf7, 0xeb, 0xbc, 0x3a, 0x93, 0xfb, 0x75, 0x6e, 0xcd, 0x88, 0x1f, 0xb0, 0xf7, 0xbc,
	0xa6, 0xd6, 0xd3, 0xef, 0x99, 0x57, 0x7d, 0x34, 0xf2, 0x1c, 0xc2, 0x42, 0xb2, 0x62, 0xe3, 0x0f,
	0x3a, 0xb7, 0x18, 0xe4, 0x0f, 0x3a, 0xbf, 0xc0, 0xc3, 0x05, 0x74, 0x01, 0xf3, 0x89, 0x62, 0x4c,
	0x60, 0xce, 0xa9, 0xe5, 0x04, 0xe6, 0xbc, 0xca, 0x0d, 0x3f, 0x64, 0x98, 0xef, 0x6f, 0xdd, 0x4b,
	0x61, 0x16, 0xc9, 0x3c, 0x0c, 0x42, 0xcf, 0x00, 0xe2, 0xd4, 0xc5, 0xdd, 0x3f, 0x93, 0x3d, 0xb9,
	0xfb, 0x67, 0x33, 0x1c, 0x2e, 0xec, 0x35, 0xde, 0x7d, 0x68, 0x2a, 0xef, 0x3f, 0x34, 0x95, 0x3f,
	0x3f, 0x34, 0x95, 0x9f, 0x3e, 0x36, 0x0b, 0xef, 0x3f, 0x36, 0x0b, 0x7f, 0x7c, 0x6c, 0x16, 0xce,
	0xca, 0xec, 0x9f, 0xfe, 0xc9, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf2, 0xed, 0xff, 0xf6, 0xeb,
	0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MasterClient is the client API for Master service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MasterClient interface {
	StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error)
	OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error)
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error)
	QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error)
	QueryError(ctx context.Context, in *QueryErrorListRequest, opts ...grpc.CallOption) (*QueryErrorListResponse, error)
	// show un-resolved DDL locks
	ShowDDLLocks(ctx context.Context, in *ShowDDLLocksRequest, opts ...grpc.CallOption) (*ShowDDLLocksResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*UnlockDDLLockResponse, error)
	UpdateMasterConfig(ctx context.Context, in *UpdateMasterConfigRequest, opts ...grpc.CallOption) (*UpdateMasterConfigResponse, error)
	UpdateWorkerRelayConfig(ctx context.Context, in *UpdateWorkerRelayConfigRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error)
	HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*HandleSQLsResponse, error)
	// SwitchWorkerRelayMaster requests some dm-workers to switch relay unit's master server
	SwitchWorkerRelayMaster(ctx context.Context, in *SwitchWorkerRelayMasterRequest, opts ...grpc.CallOption) (*SwitchWorkerRelayMasterResponse, error)
	// OperateWorkerRelayTask requests some dm-workers to operate relay unit
	OperateWorkerRelayTask(ctx context.Context, in *OperateWorkerRelayRequest, opts ...grpc.CallOption) (*OperateWorkerRelayResponse, error)
	// PurgeWorkerRelay purges relay log files for some dm-workers
	PurgeWorkerRelay(ctx context.Context, in *PurgeWorkerRelayRequest, opts ...grpc.CallOption) (*PurgeWorkerRelayResponse, error)
	// MigrateRelay request migrate old dm-woker to a new one.
	MigrateWorkerRelay(ctx context.Context, in *MigrateWorkerRelayRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error)
	// CheckTask checks legality of task configuration
	CheckTask(ctx context.Context, in *CheckTaskRequest, opts ...grpc.CallOption) (*CheckTaskResponse, error)
	// Operate an upstream MySQL source.
	OperateSource(ctx context.Context, in *OperateSourceRequest, opts ...grpc.CallOption) (*OperateSourceResponse, error)
	// RegisterWorker register the dm-workers.
	RegisterWorker(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*RegisterWorkerResponse, error)
	// OfflineWorker offline the dm-workers.
	OfflineWorker(ctx context.Context, in *OfflineWorkerRequest, opts ...grpc.CallOption) (*OfflineWorkerResponse, error)
	// ListMember list member information
	ListMember(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberResponse, error)
}

type masterClient struct {
	cc *grpc.ClientConn
}

func NewMasterClient(cc *grpc.ClientConn) MasterClient {
	return &masterClient{cc}
}

func (c *masterClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error) {
	out := new(StartTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/StartTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error) {
	out := new(OperateTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error) {
	out := new(UpdateTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error) {
	out := new(QueryStatusListResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/QueryStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) QueryError(ctx context.Context, in *QueryErrorListRequest, opts ...grpc.CallOption) (*QueryErrorListResponse, error) {
	out := new(QueryErrorListResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/QueryError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ShowDDLLocks(ctx context.Context, in *ShowDDLLocksRequest, opts ...grpc.CallOption) (*ShowDDLLocksResponse, error) {
	out := new(ShowDDLLocksResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/ShowDDLLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*UnlockDDLLockResponse, error) {
	out := new(UnlockDDLLockResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UnlockDDLLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateMasterConfig(ctx context.Context, in *UpdateMasterConfigRequest, opts ...grpc.CallOption) (*UpdateMasterConfigResponse, error) {
	out := new(UpdateMasterConfigResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateMasterConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateWorkerRelayConfig(ctx context.Context, in *UpdateWorkerRelayConfigRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error) {
	out := new(CommonWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateWorkerRelayConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*HandleSQLsResponse, error) {
	out := new(HandleSQLsResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/HandleSQLs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) SwitchWorkerRelayMaster(ctx context.Context, in *SwitchWorkerRelayMasterRequest, opts ...grpc.CallOption) (*SwitchWorkerRelayMasterResponse, error) {
	out := new(SwitchWorkerRelayMasterResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/SwitchWorkerRelayMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateWorkerRelayTask(ctx context.Context, in *OperateWorkerRelayRequest, opts ...grpc.CallOption) (*OperateWorkerRelayResponse, error) {
	out := new(OperateWorkerRelayResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateWorkerRelayTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) PurgeWorkerRelay(ctx context.Context, in *PurgeWorkerRelayRequest, opts ...grpc.CallOption) (*PurgeWorkerRelayResponse, error) {
	out := new(PurgeWorkerRelayResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/PurgeWorkerRelay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) MigrateWorkerRelay(ctx context.Context, in *MigrateWorkerRelayRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error) {
	out := new(CommonWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/MigrateWorkerRelay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) CheckTask(ctx context.Context, in *CheckTaskRequest, opts ...grpc.CallOption) (*CheckTaskResponse, error) {
	out := new(CheckTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/CheckTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateSource(ctx context.Context, in *OperateSourceRequest, opts ...grpc.CallOption) (*OperateSourceResponse, error) {
	out := new(OperateSourceResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) RegisterWorker(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*RegisterWorkerResponse, error) {
	out := new(RegisterWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/RegisterWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OfflineWorker(ctx context.Context, in *OfflineWorkerRequest, opts ...grpc.CallOption) (*OfflineWorkerResponse, error) {
	out := new(OfflineWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OfflineWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ListMember(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberResponse, error) {
	out := new(ListMemberResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/ListMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterServer is the server API for Master service.
type MasterServer interface {
	StartTask(context.Context, *StartTaskRequest) (*StartTaskResponse, error)
	OperateTask(context.Context, *OperateTaskRequest) (*OperateTaskResponse, error)
	UpdateTask(context.Context, *UpdateTaskRequest) (*UpdateTaskResponse, error)
	QueryStatus(context.Context, *QueryStatusListRequest) (*QueryStatusListResponse, error)
	QueryError(context.Context, *QueryErrorListRequest) (*QueryErrorListResponse, error)
	// show un-resolved DDL locks
	ShowDDLLocks(context.Context, *ShowDDLLocksRequest) (*ShowDDLLocksResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(context.Context, *UnlockDDLLockRequest) (*UnlockDDLLockResponse, error)
	UpdateMasterConfig(context.Context, *UpdateMasterConfigRequest) (*UpdateMasterConfigResponse, error)
	UpdateWorkerRelayConfig(context.Context, *UpdateWorkerRelayConfigRequest) (*CommonWorkerResponse, error)
	HandleSQLs(context.Context, *HandleSQLsRequest) (*HandleSQLsResponse, error)
	// SwitchWorkerRelayMaster requests some dm-workers to switch relay unit's master server
	SwitchWorkerRelayMaster(context.Context, *SwitchWorkerRelayMasterRequest) (*SwitchWorkerRelayMasterResponse, error)
	// OperateWorkerRelayTask requests some dm-workers to operate relay unit
	OperateWorkerRelayTask(context.Context, *OperateWorkerRelayRequest) (*OperateWorkerRelayResponse, error)
	// PurgeWorkerRelay purges relay log files for some dm-workers
	PurgeWorkerRelay(context.Context, *PurgeWorkerRelayRequest) (*PurgeWorkerRelayResponse, error)
	// MigrateRelay request migrate old dm-woker to a new one.
	MigrateWorkerRelay(context.Context, *MigrateWorkerRelayRequest) (*CommonWorkerResponse, error)
	// CheckTask checks legality of task configuration
	CheckTask(context.Context, *CheckTaskRequest) (*CheckTaskResponse, error)
	// Operate an upstream MySQL source.
	OperateSource(context.Context, *OperateSourceRequest) (*OperateSourceResponse, error)
	// RegisterWorker register the dm-workers.
	RegisterWorker(context.Context, *RegisterWorkerRequest) (*RegisterWorkerResponse, error)
	// OfflineWorker offline the dm-workers.
	OfflineWorker(context.Context, *OfflineWorkerRequest) (*OfflineWorkerResponse, error)
	// ListMember list member information
	ListMember(context.Context, *ListMemberRequest) (*ListMemberResponse, error)
}

// UnimplementedMasterServer can be embedded to have forward compatible implementations.
type UnimplementedMasterServer struct {
}

func (*UnimplementedMasterServer) StartTask(ctx context.Context, req *StartTaskRequest) (*StartTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTask not implemented")
}
func (*UnimplementedMasterServer) OperateTask(ctx context.Context, req *OperateTaskRequest) (*OperateTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateTask not implemented")
}
func (*UnimplementedMasterServer) UpdateTask(ctx context.Context, req *UpdateTaskRequest) (*UpdateTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTask not implemented")
}
func (*UnimplementedMasterServer) QueryStatus(ctx context.Context, req *QueryStatusListRequest) (*QueryStatusListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStatus not implemented")
}
func (*UnimplementedMasterServer) QueryError(ctx context.Context, req *QueryErrorListRequest) (*QueryErrorListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryError not implemented")
}
func (*UnimplementedMasterServer) ShowDDLLocks(ctx context.Context, req *ShowDDLLocksRequest) (*ShowDDLLocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowDDLLocks not implemented")
}
func (*UnimplementedMasterServer) UnlockDDLLock(ctx context.Context, req *UnlockDDLLockRequest) (*UnlockDDLLockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockDDLLock not implemented")
}
func (*UnimplementedMasterServer) UpdateMasterConfig(ctx context.Context, req *UpdateMasterConfigRequest) (*UpdateMasterConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMasterConfig not implemented")
}
func (*UnimplementedMasterServer) UpdateWorkerRelayConfig(ctx context.Context, req *UpdateWorkerRelayConfigRequest) (*CommonWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerRelayConfig not implemented")
}
func (*UnimplementedMasterServer) HandleSQLs(ctx context.Context, req *HandleSQLsRequest) (*HandleSQLsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleSQLs not implemented")
}
func (*UnimplementedMasterServer) SwitchWorkerRelayMaster(ctx context.Context, req *SwitchWorkerRelayMasterRequest) (*SwitchWorkerRelayMasterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchWorkerRelayMaster not implemented")
}
func (*UnimplementedMasterServer) OperateWorkerRelayTask(ctx context.Context, req *OperateWorkerRelayRequest) (*OperateWorkerRelayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateWorkerRelayTask not implemented")
}
func (*UnimplementedMasterServer) PurgeWorkerRelay(ctx context.Context, req *PurgeWorkerRelayRequest) (*PurgeWorkerRelayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurgeWorkerRelay not implemented")
}
func (*UnimplementedMasterServer) MigrateWorkerRelay(ctx context.Context, req *MigrateWorkerRelayRequest) (*CommonWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateWorkerRelay not implemented")
}
func (*UnimplementedMasterServer) CheckTask(ctx context.Context, req *CheckTaskRequest) (*CheckTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckTask not implemented")
}
func (*UnimplementedMasterServer) OperateSource(ctx context.Context, req *OperateSourceRequest) (*OperateSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateSource not implemented")
}
func (*UnimplementedMasterServer) RegisterWorker(ctx context.Context, req *RegisterWorkerRequest) (*RegisterWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterWorker not implemented")
}
func (*UnimplementedMasterServer) OfflineWorker(ctx context.Context, req *OfflineWorkerRequest) (*OfflineWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OfflineWorker not implemented")
}
func (*UnimplementedMasterServer) ListMember(ctx context.Context, req *ListMemberRequest) (*ListMemberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMember not implemented")
}

func RegisterMasterServer(s *grpc.Server, srv MasterServer) {
	s.RegisterService(&_Master_serviceDesc, srv)
}

func _Master_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).StartTask(ctx, req.(*StartTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateTask(ctx, req.(*OperateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_QueryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStatusListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).QueryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/QueryStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).QueryStatus(ctx, req.(*QueryStatusListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_QueryError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryErrorListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).QueryError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/QueryError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).QueryError(ctx, req.(*QueryErrorListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ShowDDLLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowDDLLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ShowDDLLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ShowDDLLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ShowDDLLocks(ctx, req.(*ShowDDLLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UnlockDDLLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockDDLLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UnlockDDLLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UnlockDDLLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UnlockDDLLock(ctx, req.(*UnlockDDLLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateMasterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMasterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateMasterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateMasterConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateMasterConfig(ctx, req.(*UpdateMasterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateWorkerRelayConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerRelayConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateWorkerRelayConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateWorkerRelayConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateWorkerRelayConfig(ctx, req.(*UpdateWorkerRelayConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_HandleSQLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleSQLsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).HandleSQLs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/HandleSQLs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).HandleSQLs(ctx, req.(*HandleSQLsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_SwitchWorkerRelayMaster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchWorkerRelayMasterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).SwitchWorkerRelayMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/SwitchWorkerRelayMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).SwitchWorkerRelayMaster(ctx, req.(*SwitchWorkerRelayMasterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateWorkerRelayTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateWorkerRelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateWorkerRelayTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateWorkerRelayTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateWorkerRelayTask(ctx, req.(*OperateWorkerRelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_PurgeWorkerRelay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurgeWorkerRelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).PurgeWorkerRelay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/PurgeWorkerRelay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).PurgeWorkerRelay(ctx, req.(*PurgeWorkerRelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_MigrateWorkerRelay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateWorkerRelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).MigrateWorkerRelay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/MigrateWorkerRelay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).MigrateWorkerRelay(ctx, req.(*MigrateWorkerRelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_CheckTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).CheckTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/CheckTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).CheckTask(ctx, req.(*CheckTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateSource(ctx, req.(*OperateSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_RegisterWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).RegisterWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/RegisterWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).RegisterWorker(ctx, req.(*RegisterWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OfflineWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OfflineWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OfflineWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OfflineWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OfflineWorker(ctx, req.(*OfflineWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ListMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ListMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ListMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ListMember(ctx, req.(*ListMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Master_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Master",
	HandlerType: (*MasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTask",
			Handler:    _Master_StartTask_Handler,
		},
		{
			MethodName: "OperateTask",
			Handler:    _Master_OperateTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Master_UpdateTask_Handler,
		},
		{
			MethodName: "QueryStatus",
			Handler:    _Master_QueryStatus_Handler,
		},
		{
			MethodName: "QueryError",
			Handler:    _Master_QueryError_Handler,
		},
		{
			MethodName: "ShowDDLLocks",
			Handler:    _Master_ShowDDLLocks_Handler,
		},
		{
			MethodName: "UnlockDDLLock",
			Handler:    _Master_UnlockDDLLock_Handler,
		},
		{
			MethodName: "UpdateMasterConfig",
			Handler:    _Master_UpdateMasterConfig_Handler,
		},
		{
			MethodName: "UpdateWorkerRelayConfig",
			Handler:    _Master_UpdateWorkerRelayConfig_Handler,
		},
		{
			MethodName: "HandleSQLs",
			Handler:    _Master_HandleSQLs_Handler,
		},
		{
			MethodName: "SwitchWorkerRelayMaster",
			Handler:    _Master_SwitchWorkerRelayMaster_Handler,
		},
		{
			MethodName: "OperateWorkerRelayTask",
			Handler:    _Master_OperateWorkerRelayTask_Handler,
		},
		{
			MethodName: "PurgeWorkerRelay",
			Handler:    _Master_PurgeWorkerRelay_Handler,
		},
		{
			MethodName: "MigrateWorkerRelay",
			Handler:    _Master_MigrateWorkerRelay_Handler,
		},
		{
			MethodName: "CheckTask",
			Handler:    _Master_CheckTask_Handler,
		},
		{
			MethodName: "OperateSource",
			Handler:    _Master_OperateSource_Handler,
		},
		{
			MethodName: "RegisterWorker",
			Handler:    _Master_RegisterWorker_Handler,
		},
		{
			MethodName: "OfflineWorker",
			Handler:    _Master_OfflineWorker_Handler,
		},
		{
			MethodName: "ListMember",
			Handler:    _Master_ListMember_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dmmaster.proto",
}

func (m *MigrateWorkerRelayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateWorkerRelayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateWorkerRelayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BinlogPos != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.BinlogPos))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BinlogName) > 0 {
		i -= len(m.BinlogName)
		copy(dAtA[i:], m.BinlogName)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.BinlogName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateWorkerRelayConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateWorkerRelayConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateWorkerRelayConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoveMeta {
		i--
		if m.RemoveMeta {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMasterConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMasterConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMasterConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMasterConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMasterConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMasterConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryStatusListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryStatusListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryStatusListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryStatusListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryErrorListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryErrorListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryErrorListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryErrorListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryErrorListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryErrorListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowDDLLocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDDLLocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowDDLLocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DDLLock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DDLLock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DDLLock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unsynced) > 0 {
		for iNdEx := len(m.Unsynced) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Unsynced[iNdEx])
			copy(dAtA[i:], m.Unsynced[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Unsynced[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Synced) > 0 {
		for iNdEx := len(m.Synced) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Synced[iNdEx])
			copy(dAtA[i:], m.Synced[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Synced[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DDLs) > 0 {
		for iNdEx := len(m.DDLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DDLs[iNdEx])
			copy(dAtA[i:], m.DDLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.DDLs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShowDDLLocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDDLLocksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowDDLLocksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Locks) > 0 {
		for iNdEx := len(m.Locks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnlockDDLLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockDDLLockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockDDLLockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceRemove {
		i--
		if m.ForceRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReplaceOwner) > 0 {
		i -= len(m.ReplaceOwner)
		copy(dAtA[i:], m.ReplaceOwner)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ReplaceOwner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockDDLLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockDDLLockResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockDDLLockResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SwitchWorkerRelayMasterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWorkerRelayMasterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchWorkerRelayMasterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwitchWorkerRelayMasterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWorkerRelayMasterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchWorkerRelayMasterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateWorkerRelayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateWorkerRelayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateWorkerRelayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateWorkerRelayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateWorkerRelayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateWorkerRelayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HandleSQLsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSQLsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandleSQLsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sharding {
		i--
		if m.Sharding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.SqlPattern) > 0 {
		i -= len(m.SqlPattern)
		copy(dAtA[i:], m.SqlPattern)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.SqlPattern)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BinlogPos) > 0 {
		i -= len(m.BinlogPos)
		copy(dAtA[i:], m.BinlogPos)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.BinlogPos)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HandleSQLsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSQLsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandleSQLsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PurgeWorkerRelayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurgeWorkerRelayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurgeWorkerRelayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubDir) > 0 {
		i -= len(m.SubDir)
		copy(dAtA[i:], m.SubDir)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.SubDir)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if m.Time != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.Inactive {
		i--
		if m.Inactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PurgeWorkerRelayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurgeWorkerRelayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurgeWorkerRelayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateSourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateSourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateSourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateSourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateSourceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateSourceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWorkerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWorkerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWorkerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OfflineWorkerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfflineWorkerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfflineWorkerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OfflineWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfflineWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfflineWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MasterInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MasterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MasterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientURLs) > 0 {
		for iNdEx := len(m.ClientURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClientURLs[iNdEx])
			copy(dAtA[i:], m.ClientURLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ClientURLs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PeerURLs) > 0 {
		for iNdEx := len(m.PeerURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerURLs[iNdEx])
			copy(dAtA[i:], m.PeerURLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.PeerURLs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Alive {
		i--
		if m.Alive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MemberID != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Stage) > 0 {
		i -= len(m.Stage)
		copy(dAtA[i:], m.Stage)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Stage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListLeaderMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListLeaderMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListLeaderMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListMasterMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMasterMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMasterMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Masters) > 0 {
		for iNdEx := len(m.Masters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Masters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListWorkerMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListWorkerMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListWorkerMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Workers) > 0 {
		for iNdEx := len(m.Workers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Workers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Members) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Members) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Members) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Member != nil {
		{
			size := m.Member.Size()
			i -= size
			if _, err := m.Member.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Members_Leader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Members_Leader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDmmaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Members_Master) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Members_Master) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Master != nil {
		{
			size, err := m.Master.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDmmaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Members_Worker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Members_Worker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Worker != nil {
		{
			size, err := m.Worker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDmmaster(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ListMemberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMemberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMemberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Worker {
		i--
		if m.Worker {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Master {
		i--
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Leader {
		i--
		if m.Leader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListMemberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMemberResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMemberResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDmmaster(dAtA []byte, offset int, v uint64) int {
	offset -= sovDmmaster(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MigrateWorkerRelayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BinlogName)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.BinlogPos != 0 {
		n += 1 + sovDmmaster(uint64(m.BinlogPos))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *UpdateWorkerRelayConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *StartTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.RemoveMeta {
		n += 2
	}
	return n
}

func (m *StartTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UpdateMasterConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *UpdateMasterConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UpdateTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UpdateTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryStatusListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryStatusListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryErrorListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryErrorListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ShowDDLLocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *DDLLock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.DDLs) > 0 {
		for _, s := range m.DDLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.Synced) > 0 {
		for _, s := range m.Synced {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.Unsynced) > 0 {
		for _, s := range m.Unsynced {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ShowDDLLocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UnlockDDLLockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.ReplaceOwner)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.ForceRemove {
		n += 2
	}
	return n
}

func (m *UnlockDDLLockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *SwitchWorkerRelayMasterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *SwitchWorkerRelayMasterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateWorkerRelayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateWorkerRelayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *HandleSQLsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	l = len(m.BinlogPos)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.SqlPattern)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.Sharding {
		n += 2
	}
	return n
}

func (m *HandleSQLsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *PurgeWorkerRelayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.Inactive {
		n += 2
	}
	if m.Time != 0 {
		n += 1 + sovDmmaster(uint64(m.Time))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.SubDir)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *PurgeWorkerRelayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *CheckTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *CheckTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OperateSourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OperateSourceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *RegisterWorkerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *RegisterWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OfflineWorkerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OfflineWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *MasterInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.MemberID != 0 {
		n += 1 + sovDmmaster(uint64(m.MemberID))
	}
	if m.Alive {
		n += 2
	}
	if len(m.PeerURLs) > 0 {
		for _, s := range m.PeerURLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.ClientURLs) > 0 {
		for _, s := range m.ClientURLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *WorkerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Stage)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *ListLeaderMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *ListMasterMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Masters) > 0 {
		for _, e := range m.Masters {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ListWorkerMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *Members) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Member != nil {
		n += m.Member.Size()
	}
	return n
}

func (m *Members_Leader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}
func (m *Members_Master) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Master != nil {
		l = m.Master.Size()
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}
func (m *Members_Worker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Worker != nil {
		l = m.Worker.Size()
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}
func (m *ListMemberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leader {
		n += 2
	}
	if m.Master {
		n += 2
	}
	if m.Worker {
		n += 2
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ListMemberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func sovDmmaster(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDmmaster(x uint64) (n int) {
	return sovDmmaster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MigrateWorkerRelayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateWorkerRelayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateWorkerRelayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinlogName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogPos", wireType)
			}
			m.BinlogPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinlogPos |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateWorkerRelayConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateWorkerRelayConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateWorkerRelayConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveMeta", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveMeta = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMasterConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMasterConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMasterConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMasterConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMasterConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMasterConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &QueryStatusResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= TaskOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= TaskOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &QueryStatusResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryErrorListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryErrorListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryErrorListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryErrorListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryErrorListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryErrorListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &QueryErrorResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDDLLocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDDLLocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDDLLocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DDLLock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDLLock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDLLock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DDLs = append(m.DDLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Synced = append(m.Synced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsynced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unsynced = append(m.Unsynced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDDLLocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDDLLocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDDLLocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &DDLLock{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockDDLLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplaceOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceRemove = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockDDLLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockDDLLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockDDLLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWorkerRelayMasterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWorkerRelayMasterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateWorkerRelayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateWorkerRelayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateWorkerRelayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= RelayOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateWorkerRelayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateWorkerRelayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateWorkerRelayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= RelayOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSQLsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSQLsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSQLsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= SQLOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogPos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinlogPos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlPattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlPattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sharding = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSQLsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSQLsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSQLsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PurgeWorkerRelayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurgeWorkerRelayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurgeWorkerRelayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inactive = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PurgeWorkerRelayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurgeWorkerRelayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurgeWorkerRelayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateSourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateSourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateSourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= SourceOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateSourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateSourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateSourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWorkerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWorkerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWorkerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfflineWorkerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfflineWorkerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfflineWorkerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfflineWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfflineWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfflineWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MasterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MasterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MasterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Alive = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerURLs = append(m.PeerURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientURLs = append(m.ClientURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListLeaderMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListLeaderMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListLeaderMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMasterMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMasterMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMasterMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Masters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Masters = append(m.Masters, &MasterInfo{})
			if err := m.Masters[len(m.Masters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListWorkerMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListWorkerMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListWorkerMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &WorkerInfo{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Members) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Members: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Members: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListLeaderMember{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Member = &Members_Leader{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListMasterMember{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Member = &Members_Master{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListWorkerMember{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Member = &Members_Worker{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMemberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMemberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMemberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Leader = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Worker = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMemberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMemberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMemberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Members{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDmmaster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDmmaster
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDmmaster
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDmmaster
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDmmaster        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDmmaster          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDmmaster = fmt.Errorf("proto: unexpected end of group")
)
