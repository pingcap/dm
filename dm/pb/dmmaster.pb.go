// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dmmaster.proto

package pb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MemberType int32

const (
	MemberType_InvalidType MemberType = 0
	MemberType_MasterType  MemberType = 1
	MemberType_WorkerType  MemberType = 2
	MemberType_LeaderType  MemberType = 3
)

var MemberType_name = map[int32]string{
	0: "InvalidType",
	1: "MasterType",
	2: "WorkerType",
	3: "LeaderType",
}

var MemberType_value = map[string]int32{
	"InvalidType": 0,
	"MasterType":  1,
	"WorkerType":  2,
	"LeaderType":  3,
}

func (x MemberType) String() string {
	return proto.EnumName(MemberType_name, int32(x))
}

func (MemberType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{0}
}

type SourceOp int32

const (
	SourceOp_InvalidSourceOp SourceOp = 0
	SourceOp_StartSource     SourceOp = 1
	SourceOp_UpdateSource    SourceOp = 2
	SourceOp_StopSource      SourceOp = 3
)

var SourceOp_name = map[int32]string{
	0: "InvalidSourceOp",
	1: "StartSource",
	2: "UpdateSource",
	3: "StopSource",
}

var SourceOp_value = map[string]int32{
	"InvalidSourceOp": 0,
	"StartSource":     1,
	"UpdateSource":    2,
	"StopSource":      3,
}

func (x SourceOp) String() string {
	return proto.EnumName(SourceOp_name, int32(x))
}

func (SourceOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{1}
}

type MigrateWorkerRelayRequest struct {
	BinlogName string `protobuf:"bytes,1,opt,name=BinlogName,proto3" json:"BinlogName,omitempty"`
	BinlogPos  uint32 `protobuf:"varint,2,opt,name=BinlogPos,proto3" json:"BinlogPos,omitempty"`
	Source     string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *MigrateWorkerRelayRequest) Reset()         { *m = MigrateWorkerRelayRequest{} }
func (m *MigrateWorkerRelayRequest) String() string { return proto.CompactTextString(m) }
func (*MigrateWorkerRelayRequest) ProtoMessage()    {}
func (*MigrateWorkerRelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{0}
}
func (m *MigrateWorkerRelayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateWorkerRelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrateWorkerRelayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrateWorkerRelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateWorkerRelayRequest.Merge(m, src)
}
func (m *MigrateWorkerRelayRequest) XXX_Size() int {
	return m.Size()
}
func (m *MigrateWorkerRelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateWorkerRelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateWorkerRelayRequest proto.InternalMessageInfo

func (m *MigrateWorkerRelayRequest) GetBinlogName() string {
	if m != nil {
		return m.BinlogName
	}
	return ""
}

func (m *MigrateWorkerRelayRequest) GetBinlogPos() uint32 {
	if m != nil {
		return m.BinlogPos
	}
	return 0
}

func (m *MigrateWorkerRelayRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type UpdateWorkerRelayConfigRequest struct {
	Config string `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	Source string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *UpdateWorkerRelayConfigRequest) Reset()         { *m = UpdateWorkerRelayConfigRequest{} }
func (m *UpdateWorkerRelayConfigRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateWorkerRelayConfigRequest) ProtoMessage()    {}
func (*UpdateWorkerRelayConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{1}
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateWorkerRelayConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateWorkerRelayConfigRequest.Merge(m, src)
}
func (m *UpdateWorkerRelayConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateWorkerRelayConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateWorkerRelayConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateWorkerRelayConfigRequest proto.InternalMessageInfo

func (m *UpdateWorkerRelayConfigRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *UpdateWorkerRelayConfigRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type StartTaskRequest struct {
	Task    string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *StartTaskRequest) Reset()         { *m = StartTaskRequest{} }
func (m *StartTaskRequest) String() string { return proto.CompactTextString(m) }
func (*StartTaskRequest) ProtoMessage()    {}
func (*StartTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{2}
}
func (m *StartTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTaskRequest.Merge(m, src)
}
func (m *StartTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartTaskRequest proto.InternalMessageInfo

func (m *StartTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *StartTaskRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type StartTaskResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *StartTaskResponse) Reset()         { *m = StartTaskResponse{} }
func (m *StartTaskResponse) String() string { return proto.CompactTextString(m) }
func (*StartTaskResponse) ProtoMessage()    {}
func (*StartTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{3}
}
func (m *StartTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTaskResponse.Merge(m, src)
}
func (m *StartTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartTaskResponse proto.InternalMessageInfo

func (m *StartTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *StartTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *StartTaskResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type UpdateMasterConfigRequest struct {
	Config string `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *UpdateMasterConfigRequest) Reset()         { *m = UpdateMasterConfigRequest{} }
func (m *UpdateMasterConfigRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateMasterConfigRequest) ProtoMessage()    {}
func (*UpdateMasterConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{4}
}
func (m *UpdateMasterConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMasterConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMasterConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMasterConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMasterConfigRequest.Merge(m, src)
}
func (m *UpdateMasterConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMasterConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMasterConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMasterConfigRequest proto.InternalMessageInfo

func (m *UpdateMasterConfigRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

type UpdateMasterConfigResponse struct {
	Result  bool                   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*QueryStatusResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *UpdateMasterConfigResponse) Reset()         { *m = UpdateMasterConfigResponse{} }
func (m *UpdateMasterConfigResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateMasterConfigResponse) ProtoMessage()    {}
func (*UpdateMasterConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{5}
}
func (m *UpdateMasterConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMasterConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMasterConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMasterConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMasterConfigResponse.Merge(m, src)
}
func (m *UpdateMasterConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMasterConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMasterConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMasterConfigResponse proto.InternalMessageInfo

func (m *UpdateMasterConfigResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UpdateMasterConfigResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UpdateMasterConfigResponse) GetSources() []*QueryStatusResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type OperateTaskRequest struct {
	Op      TaskOp   `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Name    string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Sources []string `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateTaskRequest) Reset()         { *m = OperateTaskRequest{} }
func (m *OperateTaskRequest) String() string { return proto.CompactTextString(m) }
func (*OperateTaskRequest) ProtoMessage()    {}
func (*OperateTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{6}
}
func (m *OperateTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateTaskRequest.Merge(m, src)
}
func (m *OperateTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateTaskRequest proto.InternalMessageInfo

func (m *OperateTaskRequest) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperateTaskRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type OperateTaskResponse struct {
	Op      TaskOp                  `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Result  bool                    `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,4,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateTaskResponse) Reset()         { *m = OperateTaskResponse{} }
func (m *OperateTaskResponse) String() string { return proto.CompactTextString(m) }
func (*OperateTaskResponse) ProtoMessage()    {}
func (*OperateTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{7}
}
func (m *OperateTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateTaskResponse.Merge(m, src)
}
func (m *OperateTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateTaskResponse proto.InternalMessageInfo

func (m *OperateTaskResponse) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateTaskResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// UpdateTaskRequest used to update task after it has beed started
// task: task's configuration, yaml format
//       now, only support to update config for routes, filters, column-mappings, black-white-list
//       support update partial config for syncer, loader, etc later
// sources need to do update, empty for all sources in processing the task
type UpdateTaskRequest struct {
	Task    string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *UpdateTaskRequest) Reset()         { *m = UpdateTaskRequest{} }
func (m *UpdateTaskRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateTaskRequest) ProtoMessage()    {}
func (*UpdateTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{8}
}
func (m *UpdateTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTaskRequest.Merge(m, src)
}
func (m *UpdateTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTaskRequest proto.InternalMessageInfo

func (m *UpdateTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *UpdateTaskRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type UpdateTaskResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *UpdateTaskResponse) Reset()         { *m = UpdateTaskResponse{} }
func (m *UpdateTaskResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateTaskResponse) ProtoMessage()    {}
func (*UpdateTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{9}
}
func (m *UpdateTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTaskResponse.Merge(m, src)
}
func (m *UpdateTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTaskResponse proto.InternalMessageInfo

func (m *UpdateTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UpdateTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UpdateTaskResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryStatusListRequest struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryStatusListRequest) Reset()         { *m = QueryStatusListRequest{} }
func (m *QueryStatusListRequest) String() string { return proto.CompactTextString(m) }
func (*QueryStatusListRequest) ProtoMessage()    {}
func (*QueryStatusListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{10}
}
func (m *QueryStatusListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStatusListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStatusListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryStatusListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStatusListRequest.Merge(m, src)
}
func (m *QueryStatusListRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryStatusListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStatusListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStatusListRequest proto.InternalMessageInfo

func (m *QueryStatusListRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryStatusListRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryStatusListResponse struct {
	Result  bool                   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*QueryStatusResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryStatusListResponse) Reset()         { *m = QueryStatusListResponse{} }
func (m *QueryStatusListResponse) String() string { return proto.CompactTextString(m) }
func (*QueryStatusListResponse) ProtoMessage()    {}
func (*QueryStatusListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{11}
}
func (m *QueryStatusListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStatusListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStatusListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryStatusListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStatusListResponse.Merge(m, src)
}
func (m *QueryStatusListResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryStatusListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStatusListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStatusListResponse proto.InternalMessageInfo

func (m *QueryStatusListResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *QueryStatusListResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *QueryStatusListResponse) GetSources() []*QueryStatusResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryErrorListRequest struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryErrorListRequest) Reset()         { *m = QueryErrorListRequest{} }
func (m *QueryErrorListRequest) String() string { return proto.CompactTextString(m) }
func (*QueryErrorListRequest) ProtoMessage()    {}
func (*QueryErrorListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{12}
}
func (m *QueryErrorListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryErrorListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryErrorListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryErrorListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryErrorListRequest.Merge(m, src)
}
func (m *QueryErrorListRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryErrorListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryErrorListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryErrorListRequest proto.InternalMessageInfo

func (m *QueryErrorListRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryErrorListRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type QueryErrorListResponse struct {
	Result  bool                  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*QueryErrorResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *QueryErrorListResponse) Reset()         { *m = QueryErrorListResponse{} }
func (m *QueryErrorListResponse) String() string { return proto.CompactTextString(m) }
func (*QueryErrorListResponse) ProtoMessage()    {}
func (*QueryErrorListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{13}
}
func (m *QueryErrorListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryErrorListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryErrorListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryErrorListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryErrorListResponse.Merge(m, src)
}
func (m *QueryErrorListResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryErrorListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryErrorListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryErrorListResponse proto.InternalMessageInfo

func (m *QueryErrorListResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *QueryErrorListResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *QueryErrorListResponse) GetSources() []*QueryErrorResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// ShowDDLLocksRequest used to query DDL locks which are un-resolved
// task: task's name, empty for all tasks
// sources: source need to query, empty for all sources
//          any DDL lock in which the source is synced or unsynced will return
// if specify task and sources both, and sources not doing the task , it will return empty DDL locks
type ShowDDLLocksRequest struct {
	Task    string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *ShowDDLLocksRequest) Reset()         { *m = ShowDDLLocksRequest{} }
func (m *ShowDDLLocksRequest) String() string { return proto.CompactTextString(m) }
func (*ShowDDLLocksRequest) ProtoMessage()    {}
func (*ShowDDLLocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{14}
}
func (m *ShowDDLLocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDDLLocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDDLLocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowDDLLocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDDLLocksRequest.Merge(m, src)
}
func (m *ShowDDLLocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ShowDDLLocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDDLLocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDDLLocksRequest proto.InternalMessageInfo

func (m *ShowDDLLocksRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *ShowDDLLocksRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

// DDLLock represents a DDL lock info (I known the name confused with DDLLockInfo, any suggestion?)
// it been sent from dm-master to dmctl
// ID: DDL lock generated ID
// task: lock's corresponding task name
// mode: the shard DDL mode, `pessimistic` or `optimistic`.
// owner: lock's owner, a dm-worker
// DDL: DDL statement
// synced: already synced dm-workers
// unsynced: pending to sync dm-workers
type DDLLock struct {
	ID       string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Task     string   `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
	Mode     string   `protobuf:"bytes,3,opt,name=mode,proto3" json:"mode,omitempty"`
	Owner    string   `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
	DDLs     []string `protobuf:"bytes,5,rep,name=DDLs,proto3" json:"DDLs,omitempty"`
	Synced   []string `protobuf:"bytes,6,rep,name=synced,proto3" json:"synced,omitempty"`
	Unsynced []string `protobuf:"bytes,7,rep,name=unsynced,proto3" json:"unsynced,omitempty"`
}

func (m *DDLLock) Reset()         { *m = DDLLock{} }
func (m *DDLLock) String() string { return proto.CompactTextString(m) }
func (*DDLLock) ProtoMessage()    {}
func (*DDLLock) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{15}
}
func (m *DDLLock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DDLLock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DDLLock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DDLLock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDLLock.Merge(m, src)
}
func (m *DDLLock) XXX_Size() int {
	return m.Size()
}
func (m *DDLLock) XXX_DiscardUnknown() {
	xxx_messageInfo_DDLLock.DiscardUnknown(m)
}

var xxx_messageInfo_DDLLock proto.InternalMessageInfo

func (m *DDLLock) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *DDLLock) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *DDLLock) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *DDLLock) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DDLLock) GetDDLs() []string {
	if m != nil {
		return m.DDLs
	}
	return nil
}

func (m *DDLLock) GetSynced() []string {
	if m != nil {
		return m.Synced
	}
	return nil
}

func (m *DDLLock) GetUnsynced() []string {
	if m != nil {
		return m.Unsynced
	}
	return nil
}

type ShowDDLLocksResponse struct {
	Result bool       `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Locks  []*DDLLock `protobuf:"bytes,3,rep,name=locks,proto3" json:"locks,omitempty"`
}

func (m *ShowDDLLocksResponse) Reset()         { *m = ShowDDLLocksResponse{} }
func (m *ShowDDLLocksResponse) String() string { return proto.CompactTextString(m) }
func (*ShowDDLLocksResponse) ProtoMessage()    {}
func (*ShowDDLLocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{16}
}
func (m *ShowDDLLocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDDLLocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDDLLocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShowDDLLocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDDLLocksResponse.Merge(m, src)
}
func (m *ShowDDLLocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *ShowDDLLocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDDLLocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDDLLocksResponse proto.InternalMessageInfo

func (m *ShowDDLLocksResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ShowDDLLocksResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ShowDDLLocksResponse) GetLocks() []*DDLLock {
	if m != nil {
		return m.Locks
	}
	return nil
}

// UnlockDDLLockRequest used to unlock (resolve) DDL lock manually
// ID: DDL lock ID
// replaceOwner: dm-worker used to replace the original DDL lock's owner
// forceRemove: force to remove the DDL lock even fail to execute the DDL for the owner.
type UnlockDDLLockRequest struct {
	ID           string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ReplaceOwner string `protobuf:"bytes,2,opt,name=replaceOwner,proto3" json:"replaceOwner,omitempty"`
	ForceRemove  bool   `protobuf:"varint,3,opt,name=forceRemove,proto3" json:"forceRemove,omitempty"`
}

func (m *UnlockDDLLockRequest) Reset()         { *m = UnlockDDLLockRequest{} }
func (m *UnlockDDLLockRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockDDLLockRequest) ProtoMessage()    {}
func (*UnlockDDLLockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{17}
}
func (m *UnlockDDLLockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockDDLLockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockDDLLockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockDDLLockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockDDLLockRequest.Merge(m, src)
}
func (m *UnlockDDLLockRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockDDLLockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockDDLLockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockDDLLockRequest proto.InternalMessageInfo

func (m *UnlockDDLLockRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *UnlockDDLLockRequest) GetReplaceOwner() string {
	if m != nil {
		return m.ReplaceOwner
	}
	return ""
}

func (m *UnlockDDLLockRequest) GetForceRemove() bool {
	if m != nil {
		return m.ForceRemove
	}
	return false
}

type UnlockDDLLockResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *UnlockDDLLockResponse) Reset()         { *m = UnlockDDLLockResponse{} }
func (m *UnlockDDLLockResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockDDLLockResponse) ProtoMessage()    {}
func (*UnlockDDLLockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{18}
}
func (m *UnlockDDLLockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockDDLLockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockDDLLockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockDDLLockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockDDLLockResponse.Merge(m, src)
}
func (m *UnlockDDLLockResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockDDLLockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockDDLLockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockDDLLockResponse proto.InternalMessageInfo

func (m *UnlockDDLLockResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UnlockDDLLockResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// SwitchWorkerRelayMasterRequest represents a request for some dm-workers to switch relay unit's master server
// workers: relay unit in these dm-workers need to switch master server
type SwitchWorkerRelayMasterRequest struct {
	Sources []string `protobuf:"bytes,1,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *SwitchWorkerRelayMasterRequest) Reset()         { *m = SwitchWorkerRelayMasterRequest{} }
func (m *SwitchWorkerRelayMasterRequest) String() string { return proto.CompactTextString(m) }
func (*SwitchWorkerRelayMasterRequest) ProtoMessage()    {}
func (*SwitchWorkerRelayMasterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{19}
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWorkerRelayMasterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWorkerRelayMasterRequest.Merge(m, src)
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWorkerRelayMasterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWorkerRelayMasterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWorkerRelayMasterRequest proto.InternalMessageInfo

func (m *SwitchWorkerRelayMasterRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type SwitchWorkerRelayMasterResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *SwitchWorkerRelayMasterResponse) Reset()         { *m = SwitchWorkerRelayMasterResponse{} }
func (m *SwitchWorkerRelayMasterResponse) String() string { return proto.CompactTextString(m) }
func (*SwitchWorkerRelayMasterResponse) ProtoMessage()    {}
func (*SwitchWorkerRelayMasterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{20}
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWorkerRelayMasterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWorkerRelayMasterResponse.Merge(m, src)
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWorkerRelayMasterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWorkerRelayMasterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWorkerRelayMasterResponse proto.InternalMessageInfo

func (m *SwitchWorkerRelayMasterResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *SwitchWorkerRelayMasterResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SwitchWorkerRelayMasterResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// OperateWorkerRelayRequest represents a request for some dm-workers to operate relay unit
type OperateWorkerRelayRequest struct {
	Op      RelayOp  `protobuf:"varint,1,opt,name=op,proto3,enum=pb.RelayOp" json:"op,omitempty"`
	Sources []string `protobuf:"bytes,2,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateWorkerRelayRequest) Reset()         { *m = OperateWorkerRelayRequest{} }
func (m *OperateWorkerRelayRequest) String() string { return proto.CompactTextString(m) }
func (*OperateWorkerRelayRequest) ProtoMessage()    {}
func (*OperateWorkerRelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{21}
}
func (m *OperateWorkerRelayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateWorkerRelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateWorkerRelayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateWorkerRelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateWorkerRelayRequest.Merge(m, src)
}
func (m *OperateWorkerRelayRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateWorkerRelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateWorkerRelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateWorkerRelayRequest proto.InternalMessageInfo

func (m *OperateWorkerRelayRequest) GetOp() RelayOp {
	if m != nil {
		return m.Op
	}
	return RelayOp_InvalidRelayOp
}

func (m *OperateWorkerRelayRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

type OperateWorkerRelayResponse struct {
	Op      RelayOp                 `protobuf:"varint,1,opt,name=op,proto3,enum=pb.RelayOp" json:"op,omitempty"`
	Result  bool                    `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,4,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateWorkerRelayResponse) Reset()         { *m = OperateWorkerRelayResponse{} }
func (m *OperateWorkerRelayResponse) String() string { return proto.CompactTextString(m) }
func (*OperateWorkerRelayResponse) ProtoMessage()    {}
func (*OperateWorkerRelayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{22}
}
func (m *OperateWorkerRelayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateWorkerRelayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateWorkerRelayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateWorkerRelayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateWorkerRelayResponse.Merge(m, src)
}
func (m *OperateWorkerRelayResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateWorkerRelayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateWorkerRelayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateWorkerRelayResponse proto.InternalMessageInfo

func (m *OperateWorkerRelayResponse) GetOp() RelayOp {
	if m != nil {
		return m.Op
	}
	return RelayOp_InvalidRelayOp
}

func (m *OperateWorkerRelayResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateWorkerRelayResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateWorkerRelayResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type HandleSQLsRequest struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Op         SQLOp    `protobuf:"varint,2,opt,name=op,proto3,enum=pb.SQLOp" json:"op,omitempty"`
	Args       []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	BinlogPos  string   `protobuf:"bytes,4,opt,name=binlogPos,proto3" json:"binlogPos,omitempty"`
	Source     string   `protobuf:"bytes,5,opt,name=source,proto3" json:"source,omitempty"`
	SqlPattern string   `protobuf:"bytes,6,opt,name=sqlPattern,proto3" json:"sqlPattern,omitempty"`
	Sharding   bool     `protobuf:"varint,7,opt,name=sharding,proto3" json:"sharding,omitempty"`
}

func (m *HandleSQLsRequest) Reset()         { *m = HandleSQLsRequest{} }
func (m *HandleSQLsRequest) String() string { return proto.CompactTextString(m) }
func (*HandleSQLsRequest) ProtoMessage()    {}
func (*HandleSQLsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{23}
}
func (m *HandleSQLsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleSQLsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleSQLsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandleSQLsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleSQLsRequest.Merge(m, src)
}
func (m *HandleSQLsRequest) XXX_Size() int {
	return m.Size()
}
func (m *HandleSQLsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleSQLsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HandleSQLsRequest proto.InternalMessageInfo

func (m *HandleSQLsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HandleSQLsRequest) GetOp() SQLOp {
	if m != nil {
		return m.Op
	}
	return SQLOp_SKIP
}

func (m *HandleSQLsRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *HandleSQLsRequest) GetBinlogPos() string {
	if m != nil {
		return m.BinlogPos
	}
	return ""
}

func (m *HandleSQLsRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *HandleSQLsRequest) GetSqlPattern() string {
	if m != nil {
		return m.SqlPattern
	}
	return ""
}

func (m *HandleSQLsRequest) GetSharding() bool {
	if m != nil {
		return m.Sharding
	}
	return false
}

type HandleSQLsResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *HandleSQLsResponse) Reset()         { *m = HandleSQLsResponse{} }
func (m *HandleSQLsResponse) String() string { return proto.CompactTextString(m) }
func (*HandleSQLsResponse) ProtoMessage()    {}
func (*HandleSQLsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{24}
}
func (m *HandleSQLsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleSQLsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleSQLsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandleSQLsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleSQLsResponse.Merge(m, src)
}
func (m *HandleSQLsResponse) XXX_Size() int {
	return m.Size()
}
func (m *HandleSQLsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleSQLsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HandleSQLsResponse proto.InternalMessageInfo

func (m *HandleSQLsResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *HandleSQLsResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *HandleSQLsResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

// PurgeWorkerRelayRequest represents a request to purge relay log files for some dm-workers
// workers: dm-workers need to purge relay log files
// inactive: whether purge inactive relay log files
// time: whether purge relay log files before this time, the number of seconds elapsed since January 1, 1970 UTC
// filename: whether purge relay log files before this filename
// subDir: specify relay sub directory for @filename
type PurgeWorkerRelayRequest struct {
	Sources  []string `protobuf:"bytes,1,rep,name=sources,proto3" json:"sources,omitempty"`
	Inactive bool     `protobuf:"varint,2,opt,name=inactive,proto3" json:"inactive,omitempty"`
	Time     int64    `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	Filename string   `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
	SubDir   string   `protobuf:"bytes,5,opt,name=subDir,proto3" json:"subDir,omitempty"`
}

func (m *PurgeWorkerRelayRequest) Reset()         { *m = PurgeWorkerRelayRequest{} }
func (m *PurgeWorkerRelayRequest) String() string { return proto.CompactTextString(m) }
func (*PurgeWorkerRelayRequest) ProtoMessage()    {}
func (*PurgeWorkerRelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{25}
}
func (m *PurgeWorkerRelayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurgeWorkerRelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurgeWorkerRelayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurgeWorkerRelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurgeWorkerRelayRequest.Merge(m, src)
}
func (m *PurgeWorkerRelayRequest) XXX_Size() int {
	return m.Size()
}
func (m *PurgeWorkerRelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PurgeWorkerRelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PurgeWorkerRelayRequest proto.InternalMessageInfo

func (m *PurgeWorkerRelayRequest) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *PurgeWorkerRelayRequest) GetInactive() bool {
	if m != nil {
		return m.Inactive
	}
	return false
}

func (m *PurgeWorkerRelayRequest) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PurgeWorkerRelayRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *PurgeWorkerRelayRequest) GetSubDir() string {
	if m != nil {
		return m.SubDir
	}
	return ""
}

type PurgeWorkerRelayResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *PurgeWorkerRelayResponse) Reset()         { *m = PurgeWorkerRelayResponse{} }
func (m *PurgeWorkerRelayResponse) String() string { return proto.CompactTextString(m) }
func (*PurgeWorkerRelayResponse) ProtoMessage()    {}
func (*PurgeWorkerRelayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{26}
}
func (m *PurgeWorkerRelayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PurgeWorkerRelayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PurgeWorkerRelayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PurgeWorkerRelayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PurgeWorkerRelayResponse.Merge(m, src)
}
func (m *PurgeWorkerRelayResponse) XXX_Size() int {
	return m.Size()
}
func (m *PurgeWorkerRelayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PurgeWorkerRelayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PurgeWorkerRelayResponse proto.InternalMessageInfo

func (m *PurgeWorkerRelayResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *PurgeWorkerRelayResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *PurgeWorkerRelayResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type CheckTaskRequest struct {
	Task string `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
}

func (m *CheckTaskRequest) Reset()         { *m = CheckTaskRequest{} }
func (m *CheckTaskRequest) String() string { return proto.CompactTextString(m) }
func (*CheckTaskRequest) ProtoMessage()    {}
func (*CheckTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{27}
}
func (m *CheckTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckTaskRequest.Merge(m, src)
}
func (m *CheckTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckTaskRequest proto.InternalMessageInfo

func (m *CheckTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

type CheckTaskResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *CheckTaskResponse) Reset()         { *m = CheckTaskResponse{} }
func (m *CheckTaskResponse) String() string { return proto.CompactTextString(m) }
func (*CheckTaskResponse) ProtoMessage()    {}
func (*CheckTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{28}
}
func (m *CheckTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckTaskResponse.Merge(m, src)
}
func (m *CheckTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckTaskResponse proto.InternalMessageInfo

func (m *CheckTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *CheckTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type OperateSourceRequest struct {
	Op     SourceOp `protobuf:"varint,1,opt,name=op,proto3,enum=pb.SourceOp" json:"op,omitempty"`
	Config string   `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *OperateSourceRequest) Reset()         { *m = OperateSourceRequest{} }
func (m *OperateSourceRequest) String() string { return proto.CompactTextString(m) }
func (*OperateSourceRequest) ProtoMessage()    {}
func (*OperateSourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{29}
}
func (m *OperateSourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateSourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateSourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateSourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateSourceRequest.Merge(m, src)
}
func (m *OperateSourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateSourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateSourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateSourceRequest proto.InternalMessageInfo

func (m *OperateSourceRequest) GetOp() SourceOp {
	if m != nil {
		return m.Op
	}
	return SourceOp_InvalidSourceOp
}

func (m *OperateSourceRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

type OperateSourceResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Sources []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *OperateSourceResponse) Reset()         { *m = OperateSourceResponse{} }
func (m *OperateSourceResponse) String() string { return proto.CompactTextString(m) }
func (*OperateSourceResponse) ProtoMessage()    {}
func (*OperateSourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{30}
}
func (m *OperateSourceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateSourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateSourceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperateSourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateSourceResponse.Merge(m, src)
}
func (m *OperateSourceResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateSourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateSourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateSourceResponse proto.InternalMessageInfo

func (m *OperateSourceResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateSourceResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateSourceResponse) GetSources() []*CommonWorkerResponse {
	if m != nil {
		return m.Sources
	}
	return nil
}

type RegisterWorkerRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *RegisterWorkerRequest) Reset()         { *m = RegisterWorkerRequest{} }
func (m *RegisterWorkerRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterWorkerRequest) ProtoMessage()    {}
func (*RegisterWorkerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{31}
}
func (m *RegisterWorkerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWorkerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWorkerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWorkerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWorkerRequest.Merge(m, src)
}
func (m *RegisterWorkerRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWorkerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWorkerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWorkerRequest proto.InternalMessageInfo

func (m *RegisterWorkerRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RegisterWorkerRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type RegisterWorkerResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *RegisterWorkerResponse) Reset()         { *m = RegisterWorkerResponse{} }
func (m *RegisterWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterWorkerResponse) ProtoMessage()    {}
func (*RegisterWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{32}
}
func (m *RegisterWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWorkerResponse.Merge(m, src)
}
func (m *RegisterWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWorkerResponse proto.InternalMessageInfo

func (m *RegisterWorkerResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *RegisterWorkerResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type OfflineWorkerRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *OfflineWorkerRequest) Reset()         { *m = OfflineWorkerRequest{} }
func (m *OfflineWorkerRequest) String() string { return proto.CompactTextString(m) }
func (*OfflineWorkerRequest) ProtoMessage()    {}
func (*OfflineWorkerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{33}
}
func (m *OfflineWorkerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OfflineWorkerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OfflineWorkerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OfflineWorkerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OfflineWorkerRequest.Merge(m, src)
}
func (m *OfflineWorkerRequest) XXX_Size() int {
	return m.Size()
}
func (m *OfflineWorkerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OfflineWorkerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OfflineWorkerRequest proto.InternalMessageInfo

func (m *OfflineWorkerRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OfflineWorkerRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type OfflineWorkerResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *OfflineWorkerResponse) Reset()         { *m = OfflineWorkerResponse{} }
func (m *OfflineWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*OfflineWorkerResponse) ProtoMessage()    {}
func (*OfflineWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{34}
}
func (m *OfflineWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OfflineWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OfflineWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OfflineWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OfflineWorkerResponse.Merge(m, src)
}
func (m *OfflineWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *OfflineWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OfflineWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OfflineWorkerResponse proto.InternalMessageInfo

func (m *OfflineWorkerResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OfflineWorkerResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type MemberMasterResponse struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	MemberID   uint64   `protobuf:"varint,2,opt,name=memberID,proto3" json:"memberID,omitempty"`
	Alive      bool     `protobuf:"varint,3,opt,name=alive,proto3" json:"alive,omitempty"`
	PeerURLs   []string `protobuf:"bytes,4,rep,name=peerURLs,proto3" json:"peerURLs,omitempty"`
	ClientURLs []string `protobuf:"bytes,5,rep,name=clientURLs,proto3" json:"clientURLs,omitempty"`
}

func (m *MemberMasterResponse) Reset()         { *m = MemberMasterResponse{} }
func (m *MemberMasterResponse) String() string { return proto.CompactTextString(m) }
func (*MemberMasterResponse) ProtoMessage()    {}
func (*MemberMasterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{35}
}
func (m *MemberMasterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberMasterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberMasterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberMasterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberMasterResponse.Merge(m, src)
}
func (m *MemberMasterResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemberMasterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberMasterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemberMasterResponse proto.InternalMessageInfo

func (m *MemberMasterResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemberMasterResponse) GetMemberID() uint64 {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *MemberMasterResponse) GetAlive() bool {
	if m != nil {
		return m.Alive
	}
	return false
}

func (m *MemberMasterResponse) GetPeerURLs() []string {
	if m != nil {
		return m.PeerURLs
	}
	return nil
}

func (m *MemberMasterResponse) GetClientURLs() []string {
	if m != nil {
		return m.ClientURLs
	}
	return nil
}

type MemberWorkerResponse struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Addr   string `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	Stage  string `protobuf:"bytes,3,opt,name=stage,proto3" json:"stage,omitempty"`
	Source string `protobuf:"bytes,4,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *MemberWorkerResponse) Reset()         { *m = MemberWorkerResponse{} }
func (m *MemberWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*MemberWorkerResponse) ProtoMessage()    {}
func (*MemberWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{36}
}
func (m *MemberWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberWorkerResponse.Merge(m, src)
}
func (m *MemberWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemberWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemberWorkerResponse proto.InternalMessageInfo

func (m *MemberWorkerResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemberWorkerResponse) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *MemberWorkerResponse) GetStage() string {
	if m != nil {
		return m.Stage
	}
	return ""
}

func (m *MemberWorkerResponse) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type ListMemberRequest struct {
}

func (m *ListMemberRequest) Reset()         { *m = ListMemberRequest{} }
func (m *ListMemberRequest) String() string { return proto.CompactTextString(m) }
func (*ListMemberRequest) ProtoMessage()    {}
func (*ListMemberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{37}
}
func (m *ListMemberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMemberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMemberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMemberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMemberRequest.Merge(m, src)
}
func (m *ListMemberRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListMemberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMemberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListMemberRequest proto.InternalMessageInfo

type ListMemberMasterResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Members []*MemberMasterResponse `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *ListMemberMasterResponse) Reset()         { *m = ListMemberMasterResponse{} }
func (m *ListMemberMasterResponse) String() string { return proto.CompactTextString(m) }
func (*ListMemberMasterResponse) ProtoMessage()    {}
func (*ListMemberMasterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{38}
}
func (m *ListMemberMasterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMemberMasterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMemberMasterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMemberMasterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMemberMasterResponse.Merge(m, src)
}
func (m *ListMemberMasterResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListMemberMasterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMemberMasterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMemberMasterResponse proto.InternalMessageInfo

func (m *ListMemberMasterResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ListMemberMasterResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ListMemberMasterResponse) GetMembers() []*MemberMasterResponse {
	if m != nil {
		return m.Members
	}
	return nil
}

type ListMemberLeaderResponse struct {
	Result     bool     `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg        string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Name       string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	MemberID   uint64   `protobuf:"varint,4,opt,name=memberID,proto3" json:"memberID,omitempty"`
	Alive      bool     `protobuf:"varint,5,opt,name=alive,proto3" json:"alive,omitempty"`
	PeerURLs   []string `protobuf:"bytes,6,rep,name=peerURLs,proto3" json:"peerURLs,omitempty"`
	ClientURLs []string `protobuf:"bytes,7,rep,name=clientURLs,proto3" json:"clientURLs,omitempty"`
}

func (m *ListMemberLeaderResponse) Reset()         { *m = ListMemberLeaderResponse{} }
func (m *ListMemberLeaderResponse) String() string { return proto.CompactTextString(m) }
func (*ListMemberLeaderResponse) ProtoMessage()    {}
func (*ListMemberLeaderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{39}
}
func (m *ListMemberLeaderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMemberLeaderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMemberLeaderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMemberLeaderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMemberLeaderResponse.Merge(m, src)
}
func (m *ListMemberLeaderResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListMemberLeaderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMemberLeaderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMemberLeaderResponse proto.InternalMessageInfo

func (m *ListMemberLeaderResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ListMemberLeaderResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ListMemberLeaderResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListMemberLeaderResponse) GetMemberID() uint64 {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *ListMemberLeaderResponse) GetAlive() bool {
	if m != nil {
		return m.Alive
	}
	return false
}

func (m *ListMemberLeaderResponse) GetPeerURLs() []string {
	if m != nil {
		return m.PeerURLs
	}
	return nil
}

func (m *ListMemberLeaderResponse) GetClientURLs() []string {
	if m != nil {
		return m.ClientURLs
	}
	return nil
}

type ListMemberWorkerResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Members []*MemberWorkerResponse `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *ListMemberWorkerResponse) Reset()         { *m = ListMemberWorkerResponse{} }
func (m *ListMemberWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*ListMemberWorkerResponse) ProtoMessage()    {}
func (*ListMemberWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f9bef11f2a341f03, []int{40}
}
func (m *ListMemberWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMemberWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMemberWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMemberWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMemberWorkerResponse.Merge(m, src)
}
func (m *ListMemberWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListMemberWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMemberWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMemberWorkerResponse proto.InternalMessageInfo

func (m *ListMemberWorkerResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ListMemberWorkerResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ListMemberWorkerResponse) GetMembers() []*MemberWorkerResponse {
	if m != nil {
		return m.Members
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.MemberType", MemberType_name, MemberType_value)
	proto.RegisterEnum("pb.SourceOp", SourceOp_name, SourceOp_value)
	proto.RegisterType((*MigrateWorkerRelayRequest)(nil), "pb.MigrateWorkerRelayRequest")
	proto.RegisterType((*UpdateWorkerRelayConfigRequest)(nil), "pb.UpdateWorkerRelayConfigRequest")
	proto.RegisterType((*StartTaskRequest)(nil), "pb.StartTaskRequest")
	proto.RegisterType((*StartTaskResponse)(nil), "pb.StartTaskResponse")
	proto.RegisterType((*UpdateMasterConfigRequest)(nil), "pb.UpdateMasterConfigRequest")
	proto.RegisterType((*UpdateMasterConfigResponse)(nil), "pb.UpdateMasterConfigResponse")
	proto.RegisterType((*OperateTaskRequest)(nil), "pb.OperateTaskRequest")
	proto.RegisterType((*OperateTaskResponse)(nil), "pb.OperateTaskResponse")
	proto.RegisterType((*UpdateTaskRequest)(nil), "pb.UpdateTaskRequest")
	proto.RegisterType((*UpdateTaskResponse)(nil), "pb.UpdateTaskResponse")
	proto.RegisterType((*QueryStatusListRequest)(nil), "pb.QueryStatusListRequest")
	proto.RegisterType((*QueryStatusListResponse)(nil), "pb.QueryStatusListResponse")
	proto.RegisterType((*QueryErrorListRequest)(nil), "pb.QueryErrorListRequest")
	proto.RegisterType((*QueryErrorListResponse)(nil), "pb.QueryErrorListResponse")
	proto.RegisterType((*ShowDDLLocksRequest)(nil), "pb.ShowDDLLocksRequest")
	proto.RegisterType((*DDLLock)(nil), "pb.DDLLock")
	proto.RegisterType((*ShowDDLLocksResponse)(nil), "pb.ShowDDLLocksResponse")
	proto.RegisterType((*UnlockDDLLockRequest)(nil), "pb.UnlockDDLLockRequest")
	proto.RegisterType((*UnlockDDLLockResponse)(nil), "pb.UnlockDDLLockResponse")
	proto.RegisterType((*SwitchWorkerRelayMasterRequest)(nil), "pb.SwitchWorkerRelayMasterRequest")
	proto.RegisterType((*SwitchWorkerRelayMasterResponse)(nil), "pb.SwitchWorkerRelayMasterResponse")
	proto.RegisterType((*OperateWorkerRelayRequest)(nil), "pb.OperateWorkerRelayRequest")
	proto.RegisterType((*OperateWorkerRelayResponse)(nil), "pb.OperateWorkerRelayResponse")
	proto.RegisterType((*HandleSQLsRequest)(nil), "pb.HandleSQLsRequest")
	proto.RegisterType((*HandleSQLsResponse)(nil), "pb.HandleSQLsResponse")
	proto.RegisterType((*PurgeWorkerRelayRequest)(nil), "pb.PurgeWorkerRelayRequest")
	proto.RegisterType((*PurgeWorkerRelayResponse)(nil), "pb.PurgeWorkerRelayResponse")
	proto.RegisterType((*CheckTaskRequest)(nil), "pb.CheckTaskRequest")
	proto.RegisterType((*CheckTaskResponse)(nil), "pb.CheckTaskResponse")
	proto.RegisterType((*OperateSourceRequest)(nil), "pb.OperateSourceRequest")
	proto.RegisterType((*OperateSourceResponse)(nil), "pb.OperateSourceResponse")
	proto.RegisterType((*RegisterWorkerRequest)(nil), "pb.RegisterWorkerRequest")
	proto.RegisterType((*RegisterWorkerResponse)(nil), "pb.RegisterWorkerResponse")
	proto.RegisterType((*OfflineWorkerRequest)(nil), "pb.OfflineWorkerRequest")
	proto.RegisterType((*OfflineWorkerResponse)(nil), "pb.OfflineWorkerResponse")
	proto.RegisterType((*MemberMasterResponse)(nil), "pb.MemberMasterResponse")
	proto.RegisterType((*MemberWorkerResponse)(nil), "pb.MemberWorkerResponse")
	proto.RegisterType((*ListMemberRequest)(nil), "pb.ListMemberRequest")
	proto.RegisterType((*ListMemberMasterResponse)(nil), "pb.ListMemberMasterResponse")
	proto.RegisterType((*ListMemberLeaderResponse)(nil), "pb.ListMemberLeaderResponse")
	proto.RegisterType((*ListMemberWorkerResponse)(nil), "pb.ListMemberWorkerResponse")
}

func init() { proto.RegisterFile("dmmaster.proto", fileDescriptor_f9bef11f2a341f03) }

var fileDescriptor_f9bef11f2a341f03 = []byte{
	// 1608 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x25, 0x59, 0xb6, 0xc6, 0x8e, 0x23, 0xaf, 0x65, 0x99, 0x62, 0x1c, 0xc5, 0x65, 0x8b,
	0xc0, 0xc8, 0x21, 0x6e, 0x9c, 0x5b, 0x80, 0x00, 0x4d, 0x2c, 0x07, 0x35, 0x20, 0xd7, 0x0e, 0x15,
	0xa3, 0xc8, 0xa5, 0x00, 0x2d, 0xae, 0x65, 0xc2, 0x14, 0x49, 0x93, 0x94, 0x5d, 0xa3, 0x28, 0x0a,
	0xf4, 0x05, 0x5a, 0xa0, 0x87, 0xe4, 0xd6, 0xb7, 0x29, 0x72, 0x0c, 0xd0, 0x4b, 0x8f, 0x45, 0xd2,
	0x07, 0x29, 0xf6, 0x87, 0xe4, 0xf2, 0x4f, 0xb5, 0x1c, 0xd4, 0xb7, 0x9d, 0xd9, 0xdd, 0x99, 0x6f,
	0x67, 0x66, 0x67, 0x67, 0x16, 0x16, 0x8d, 0xd1, 0x48, 0xf7, 0x03, 0xec, 0x3d, 0x74, 0x3d, 0x27,
	0x70, 0x50, 0xd9, 0x3d, 0x52, 0x16, 0x8d, 0xd1, 0x85, 0xe3, 0x9d, 0x86, 0x3c, 0x65, 0x6d, 0xe8,
	0x38, 0x43, 0x0b, 0x6f, 0xea, 0xae, 0xb9, 0xa9, 0xdb, 0xb6, 0x13, 0xe8, 0x81, 0xe9, 0xd8, 0x3e,
	0x9b, 0x55, 0xcf, 0xa0, 0xbd, 0x67, 0x0e, 0x3d, 0x3d, 0xc0, 0xdf, 0xd2, 0x4d, 0x1a, 0xb6, 0xf4,
	0x4b, 0x0d, 0x9f, 0x8d, 0xb1, 0x1f, 0xa0, 0x0e, 0xc0, 0x73, 0xd3, 0xb6, 0x9c, 0xe1, 0x37, 0xfa,
	0x08, 0xcb, 0xd2, 0xba, 0xb4, 0x51, 0xd7, 0x04, 0x0e, 0x5a, 0x83, 0x3a, 0xa3, 0x0e, 0x1c, 0x5f,
	0x2e, 0xaf, 0x4b, 0x1b, 0xb7, 0xb4, 0x98, 0x81, 0x5a, 0x50, 0xf3, 0x9d, 0xb1, 0x37, 0xc0, 0x72,
	0x85, 0xee, 0xe4, 0x94, 0x7a, 0x00, 0x9d, 0x43, 0xd7, 0x48, 0x6a, 0xdc, 0x76, 0xec, 0x63, 0x73,
	0x18, 0xea, 0x6d, 0x41, 0x6d, 0x40, 0x19, 0x5c, 0x27, 0xa7, 0x04, 0x89, 0xe5, 0x84, 0xc4, 0xaf,
	0xa0, 0xd1, 0x0f, 0x74, 0x2f, 0x78, 0xa5, 0xfb, 0xa7, 0xa1, 0x0c, 0x04, 0xd5, 0x40, 0xf7, 0x4f,
	0xb9, 0x04, 0x3a, 0x46, 0x32, 0xcc, 0xb2, 0x1d, 0x04, 0x6d, 0x65, 0xa3, 0xae, 0x85, 0xa4, 0x7a,
	0x06, 0x4b, 0x82, 0x04, 0xdf, 0x75, 0x6c, 0x1f, 0x13, 0x75, 0x1e, 0xf6, 0xc7, 0x56, 0x40, 0x85,
	0xcc, 0x69, 0x9c, 0x42, 0x0d, 0xa8, 0x8c, 0xfc, 0x21, 0xc7, 0x40, 0x86, 0x68, 0x2b, 0x16, 0x5c,
	0x59, 0xaf, 0x6c, 0xcc, 0x6f, 0xc9, 0x0f, 0xdd, 0xa3, 0x87, 0xdb, 0xce, 0x68, 0xe4, 0xd8, 0xe1,
	0x29, 0x99, 0xd0, 0x58, 0xe5, 0x63, 0x68, 0x33, 0x33, 0xec, 0x51, 0x0f, 0x5e, 0xc9, 0x02, 0xea,
	0x25, 0x28, 0x79, 0x9b, 0xa6, 0x06, 0xfc, 0x28, 0x0d, 0x78, 0x95, 0x00, 0x7e, 0x39, 0xc6, 0xde,
	0x65, 0x3f, 0xd0, 0x83, 0xb1, 0x9f, 0xc5, 0xfb, 0x1d, 0xa0, 0x7d, 0x17, 0x93, 0x48, 0x11, 0xcd,
	0xac, 0x40, 0xd9, 0x71, 0xa9, 0xba, 0xc5, 0x2d, 0x20, 0x32, 0xc8, 0xe4, 0xbe, 0xab, 0x95, 0x1d,
	0x97, 0xb8, 0xc0, 0x26, 0x81, 0xc3, 0xf4, 0xd2, 0xb1, 0xe8, 0x82, 0x4a, 0xd2, 0x05, 0xbf, 0x48,
	0xb0, 0x9c, 0x50, 0xc0, 0x0f, 0x35, 0x49, 0x43, 0x7c, 0xe0, 0x72, 0xde, 0x81, 0x2b, 0xb9, 0x1e,
	0xaa, 0x5e, 0xd5, 0x43, 0xcf, 0x60, 0x89, 0x19, 0xfb, 0xfa, 0x71, 0xe5, 0x01, 0x12, 0x45, 0xdc,
	0x48, 0x60, 0xbd, 0x80, 0x96, 0xe0, 0xc8, 0x9e, 0xe9, 0x07, 0x02, 0x76, 0x3b, 0xbe, 0xc9, 0x19,
	0x87, 0xa4, 0xb0, 0x9f, 0xc3, 0x6a, 0x46, 0xce, 0x4d, 0x04, 0xda, 0x0e, 0xac, 0xd0, 0xf9, 0x1d,
	0xcf, 0x73, 0xbc, 0xeb, 0xc3, 0x0f, 0xb8, 0x19, 0x04, 0x31, 0x53, 0xa3, 0xff, 0x32, 0x8d, 0xbe,
	0x15, 0xa1, 0xa7, 0x62, 0xb3, 0xe0, 0xb7, 0x61, 0xb9, 0x7f, 0xe2, 0x5c, 0x74, 0xbb, 0xbd, 0x9e,
	0x33, 0x38, 0xf5, 0xaf, 0x17, 0x35, 0xbf, 0x4b, 0x30, 0xcb, 0x25, 0xa0, 0x45, 0x28, 0xef, 0x76,
	0xf9, 0xbe, 0xf2, 0x6e, 0x37, 0x92, 0x54, 0x16, 0x24, 0x21, 0xa8, 0x8e, 0x1c, 0x23, 0xcc, 0xb3,
	0x74, 0x8c, 0x9a, 0x30, 0xe3, 0x5c, 0xd8, 0xd8, 0x93, 0xab, 0x94, 0xc9, 0x08, 0xb2, 0xb2, 0xdb,
	0xed, 0xf9, 0xf2, 0x0c, 0x55, 0x48, 0xc7, 0x34, 0xab, 0x5e, 0xda, 0x03, 0x6c, 0xc8, 0x35, 0xca,
	0xe5, 0x14, 0x52, 0x60, 0x6e, 0x6c, 0xf3, 0x99, 0x59, 0x3a, 0x13, 0xd1, 0xea, 0x00, 0x9a, 0xc9,
	0x63, 0x4e, 0x6d, 0xda, 0xcf, 0x60, 0xc6, 0x22, 0x5b, 0xb9, 0x61, 0xe7, 0x89, 0x61, 0xb9, 0x38,
	0x8d, 0xcd, 0xa8, 0x16, 0x34, 0x0f, 0x6d, 0x32, 0x0c, 0xf9, 0xdc, 0x98, 0x69, 0x93, 0xa8, 0xb0,
	0xe0, 0x61, 0xd7, 0xd2, 0x07, 0x78, 0x9f, 0x9e, 0x98, 0x69, 0x49, 0xf0, 0xd0, 0x3a, 0xcc, 0x1f,
	0x3b, 0xde, 0x00, 0x6b, 0x78, 0xe4, 0x9c, 0x33, 0x4b, 0xcd, 0x69, 0x22, 0x4b, 0x7d, 0x06, 0x2b,
	0x29, 0x6d, 0xd3, 0x9e, 0x49, 0x7d, 0x02, 0x9d, 0xfe, 0x85, 0x19, 0x0c, 0x4e, 0x84, 0x97, 0x8d,
	0x25, 0xea, 0x10, 0xba, 0xe0, 0x73, 0x29, 0xe9, 0xf3, 0x9f, 0xe0, 0x5e, 0xe1, 0xde, 0x1b, 0x49,
	0x1b, 0x1a, 0xb4, 0x79, 0xfa, 0xcd, 0xa9, 0x04, 0xee, 0x08, 0x49, 0x98, 0xba, 0x8a, 0xce, 0xf2,
	0x2c, 0x5c, 0x1c, 0xc8, 0x6f, 0x24, 0x50, 0xf2, 0x84, 0xf2, 0x03, 0x4d, 0x94, 0xfa, 0xff, 0xe6,
	0xf6, 0x77, 0x12, 0x2c, 0x7d, 0xad, 0xdb, 0x86, 0x85, 0xfb, 0x2f, 0x7b, 0xfe, 0xa4, 0x0c, 0xd3,
	0xa6, 0x20, 0xcb, 0x14, 0x64, 0x9d, 0x08, 0xee, 0xbf, 0xec, 0xc5, 0x0f, 0x9c, 0xee, 0x0d, 0xc3,
	0x97, 0x8c, 0x8e, 0x49, 0x4d, 0x74, 0x14, 0xd5, 0x44, 0xec, 0xee, 0xc5, 0x0c, 0xa1, 0x82, 0x99,
	0x11, 0x2b, 0x18, 0x52, 0x69, 0xf9, 0x67, 0xd6, 0x81, 0x1e, 0x04, 0xd8, 0xb3, 0xe5, 0x1a, 0xab,
	0xb4, 0x62, 0x0e, 0xb9, 0x8b, 0xfe, 0x89, 0xee, 0x19, 0xa6, 0x3d, 0x94, 0x67, 0xa9, 0x39, 0x22,
	0x9a, 0xbc, 0x31, 0xe2, 0x49, 0x6e, 0x24, 0x58, 0xde, 0x48, 0xb0, 0x7a, 0x30, 0xf6, 0x86, 0x79,
	0xb1, 0x52, 0x18, 0xe3, 0xe4, 0x14, 0xa6, 0xad, 0x0f, 0x02, 0xf3, 0x1c, 0x73, 0xa7, 0x46, 0x34,
	0xcd, 0x6b, 0xe6, 0x88, 0xdd, 0xcc, 0x8a, 0x46, 0xc7, 0x64, 0xfd, 0xb1, 0x69, 0x61, 0xea, 0x12,
	0x66, 0xca, 0x88, 0xa6, 0x96, 0x1c, 0x1f, 0x75, 0x4d, 0x2f, 0xb2, 0x24, 0xa5, 0xd4, 0xef, 0x41,
	0xce, 0x02, 0xbb, 0x11, 0x9b, 0xdc, 0x87, 0xc6, 0xf6, 0x09, 0x1e, 0x9c, 0xfe, 0x47, 0xb5, 0xa0,
	0x3e, 0x85, 0x25, 0x61, 0xdd, 0xd4, 0x49, 0xa6, 0x07, 0x4d, 0x7e, 0xa5, 0xfa, 0x54, 0x71, 0xa8,
	0x6a, 0x4d, 0xb8, 0x4c, 0x0b, 0x34, 0x4e, 0xe9, 0x74, 0x7c, 0x9b, 0x78, 0x41, 0x59, 0x4e, 0x14,
	0x94, 0x63, 0x58, 0x49, 0x49, 0xbb, 0x11, 0x5b, 0xed, 0xc0, 0x8a, 0x86, 0x87, 0x26, 0x49, 0x6f,
	0xe1, 0x92, 0x89, 0x6f, 0xbc, 0x6e, 0x18, 0x1e, 0xf6, 0x7d, 0xae, 0x36, 0x24, 0xd5, 0xe7, 0xd0,
	0x4a, 0x8b, 0x99, 0xda, 0x9e, 0x5d, 0x68, 0xee, 0x1f, 0x1f, 0x5b, 0xa6, 0x8d, 0x3f, 0x05, 0xc9,
	0x33, 0x58, 0x49, 0x49, 0x99, 0x1a, 0xc8, 0x5b, 0x09, 0x9a, 0x7b, 0x78, 0x74, 0x84, 0xbd, 0x54,
	0xde, 0xcf, 0x43, 0xa2, 0xc0, 0xdc, 0x88, 0xae, 0xdd, 0xed, 0x52, 0x19, 0x55, 0x2d, 0xa2, 0xc9,
	0xd3, 0xaf, 0x5b, 0x66, 0xf4, 0xca, 0x31, 0x82, 0xec, 0x70, 0x31, 0xf6, 0x0e, 0xb5, 0x1e, 0x4b,
	0x93, 0x75, 0x2d, 0xa2, 0x49, 0xfa, 0x19, 0x58, 0x26, 0xb6, 0x03, 0x3a, 0xcb, 0x8a, 0x03, 0x81,
	0x43, 0x5e, 0x62, 0x86, 0x2c, 0x75, 0xb8, 0x3c, 0x64, 0x24, 0x29, 0x1a, 0x46, 0xf8, 0x0a, 0xd3,
	0x31, 0x41, 0xe4, 0x07, 0xfa, 0x30, 0xac, 0x50, 0x18, 0x21, 0x24, 0xc3, 0x6a, 0xa2, 0x9d, 0x5b,
	0x86, 0x25, 0x52, 0xaf, 0x31, 0x8d, 0xdc, 0x1d, 0xe4, 0x5e, 0xc7, 0xcc, 0x4f, 0x79, 0x18, 0x99,
	0x99, 0x12, 0xb1, 0x9a, 0x27, 0x54, 0x0b, 0x17, 0xaa, 0x7f, 0x48, 0xa2, 0xea, 0x1e, 0xd6, 0x8d,
	0x6b, 0xa9, 0x0e, 0x6d, 0x55, 0x29, 0xf0, 0x62, 0xb5, 0xc8, 0x8b, 0x33, 0x45, 0x5e, 0xac, 0x4d,
	0xf4, 0xe2, 0x6c, 0xc6, 0x8b, 0x09, 0x13, 0x5e, 0x37, 0x4c, 0x27, 0x9a, 0x30, 0x7d, 0xdd, 0xf9,
	0xc2, 0x07, 0x7b, 0x00, 0x6c, 0xc1, 0xab, 0x4b, 0x17, 0xa3, 0xdb, 0x30, 0xbf, 0x6b, 0x9f, 0xeb,
	0x96, 0x69, 0x10, 0xb2, 0x51, 0x42, 0x8b, 0x00, 0xcc, 0xf8, 0x94, 0x96, 0x08, 0xcd, 0x24, 0x51,
	0xba, 0x4c, 0x68, 0x66, 0x76, 0x4a, 0x57, 0x1e, 0x68, 0x30, 0x17, 0x26, 0x37, 0xb4, 0x0c, 0xb7,
	0xb9, 0xb0, 0x90, 0xd5, 0x28, 0x11, 0x0d, 0xb4, 0x9d, 0x67, 0xac, 0x86, 0x84, 0x1a, 0xb0, 0xc0,
	0xfa, 0x30, 0xce, 0xa1, 0x32, 0xfb, 0x81, 0xe3, 0x72, 0xba, 0xb2, 0xf5, 0xf6, 0x16, 0xd4, 0x18,
	0x08, 0xf4, 0x1a, 0xea, 0xd1, 0x67, 0x00, 0x6a, 0xd2, 0x54, 0x9a, 0xfa, 0x5d, 0x50, 0x56, 0x52,
	0x5c, 0x76, 0x60, 0xf5, 0xde, 0xcf, 0x7f, 0xfe, 0xf3, 0x5b, 0xb9, 0xad, 0x36, 0x37, 0x75, 0xd7,
	0xf4, 0x37, 0xcf, 0x1f, 0xe9, 0x96, 0x7b, 0xa2, 0x3f, 0xda, 0x24, 0x79, 0xdf, 0x7f, 0x22, 0x3d,
	0x40, 0xc7, 0x30, 0x2f, 0xf4, 0xb8, 0x88, 0xb6, 0x13, 0xd9, 0xae, 0x5a, 0x59, 0xcd, 0xf0, 0xb9,
	0x82, 0xfb, 0x54, 0xc1, 0xba, 0x72, 0x27, 0x4f, 0xc1, 0xe6, 0x0f, 0x24, 0xa8, 0x7e, 0x24, 0x7a,
	0x9e, 0x02, 0xc4, 0x7d, 0x27, 0xa2, 0x68, 0x33, 0xad, 0xac, 0xd2, 0x4a, 0xb3, 0xb9, 0x92, 0x12,
	0xb2, 0x60, 0x5e, 0x68, 0xd1, 0x90, 0x92, 0xea, 0xd9, 0x84, 0xa6, 0x4c, 0xb9, 0x93, 0x3b, 0xc7,
	0x25, 0x7d, 0x41, 0xe1, 0x76, 0xd0, 0x5a, 0x0a, 0xae, 0x4f, 0x97, 0x72, 0xbc, 0x68, 0x07, 0x20,
	0x6e, 0xa9, 0x50, 0x3b, 0xd9, 0x62, 0x89, 0xba, 0x94, 0xbc, 0xa9, 0x08, 0xf4, 0x36, 0x2c, 0x88,
	0x3d, 0x09, 0xa2, 0x46, 0xcc, 0x69, 0xc6, 0x14, 0x39, 0x3b, 0x11, 0x09, 0x79, 0x01, 0xb7, 0x12,
	0x5d, 0x00, 0xa2, 0x8b, 0xf3, 0xda, 0x10, 0xa5, 0x9d, 0x33, 0x13, 0xc9, 0x39, 0x0c, 0x1b, 0x7f,
	0xf1, 0xa3, 0x06, 0xdd, 0x8d, 0x2d, 0x9e, 0xf3, 0xeb, 0xa3, 0x74, 0x8a, 0xa6, 0x23, 0xb1, 0xaf,
	0x61, 0xb5, 0xe0, 0xef, 0x0c, 0xa9, 0xf1, 0xe6, 0xa2, 0x8f, 0x35, 0xa5, 0xf0, 0x65, 0x56, 0x4b,
	0x24, 0x64, 0xe2, 0x32, 0x92, 0x85, 0x4c, 0xa6, 0x40, 0x66, 0x21, 0x93, 0xad, 0x36, 0xd5, 0x12,
	0x32, 0x60, 0xb5, 0xa0, 0x7f, 0x61, 0xc8, 0x26, 0x37, 0x46, 0xca, 0xe7, 0x13, 0xd7, 0x08, 0xe7,
	0x6f, 0x65, 0xfb, 0x09, 0x1a, 0xe3, 0x77, 0x85, 0x2b, 0x93, 0x2d, 0x4a, 0x99, 0x69, 0x8b, 0x5b,
	0x11, 0xb5, 0x84, 0xf6, 0xa1, 0x91, 0x2e, 0x1c, 0x11, 0x0d, 0xee, 0x82, 0x3a, 0x57, 0x59, 0xcb,
	0x9f, 0x14, 0x04, 0xa2, 0xec, 0xd7, 0x2a, 0xc3, 0x59, 0xf8, 0xe5, 0x3a, 0xd1, 0x43, 0x4f, 0xa0,
	0x1e, 0x15, 0x8e, 0x2c, 0x2f, 0xa5, 0xeb, 0x4d, 0x96, 0x97, 0x32, 0xd5, 0x25, 0x8b, 0xeb, 0x44,
	0x9d, 0xc7, 0xe2, 0x3a, 0xaf, 0x90, 0x64, 0x71, 0x9d, 0x5b, 0x14, 0xaa, 0x25, 0xb4, 0x0b, 0x8b,
	0xc9, 0x8a, 0x8b, 0xdd, 0xd7, 0xdc, 0x62, 0x8e, 0xdd, 0xd7, 0xfc, 0x02, 0x8d, 0x43, 0x12, 0x4b,
	0x26, 0x0e, 0x29, 0xa7, 0x16, 0xe3, 0x90, 0xf2, 0xea, 0x2b, 0x0a, 0xa9, 0x91, 0xae, 0x0c, 0x58,
	0xf8, 0x66, 0x8a, 0x08, 0xe6, 0xb2, 0xa2, 0x32, 0x22, 0x2d, 0x8a, 0xa3, 0xba, 0x9a, 0xa8, 0xc9,
	0xa8, 0xd8, 0xeb, 0x75, 0x45, 0x51, 0xc9, 0x0a, 0x43, 0x2d, 0x3d, 0x97, 0xdf, 0x7d, 0xe8, 0x48,
	0xef, 0x3f, 0x74, 0xa4, 0xbf, 0x3f, 0x74, 0xa4, 0x5f, 0x3f, 0x76, 0x4a, 0xef, 0x3f, 0x76, 0x4a,
	0x7f, 0x7d, 0xec, 0x94, 0x8e, 0x6a, 0xf4, 0x13, 0xff, 0xf1, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x28, 0x6a, 0xf8, 0xf2, 0x08, 0x18, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MasterClient is the client API for Master service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MasterClient interface {
	StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error)
	OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error)
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error)
	QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error)
	QueryError(ctx context.Context, in *QueryErrorListRequest, opts ...grpc.CallOption) (*QueryErrorListResponse, error)
	// show un-resolved DDL locks
	ShowDDLLocks(ctx context.Context, in *ShowDDLLocksRequest, opts ...grpc.CallOption) (*ShowDDLLocksResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*UnlockDDLLockResponse, error)
	UpdateMasterConfig(ctx context.Context, in *UpdateMasterConfigRequest, opts ...grpc.CallOption) (*UpdateMasterConfigResponse, error)
	UpdateWorkerRelayConfig(ctx context.Context, in *UpdateWorkerRelayConfigRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error)
	HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*HandleSQLsResponse, error)
	// SwitchWorkerRelayMaster requests some dm-workers to switch relay unit's master server
	SwitchWorkerRelayMaster(ctx context.Context, in *SwitchWorkerRelayMasterRequest, opts ...grpc.CallOption) (*SwitchWorkerRelayMasterResponse, error)
	// OperateWorkerRelayTask requests some dm-workers to operate relay unit
	OperateWorkerRelayTask(ctx context.Context, in *OperateWorkerRelayRequest, opts ...grpc.CallOption) (*OperateWorkerRelayResponse, error)
	// PurgeWorkerRelay purges relay log files for some dm-workers
	PurgeWorkerRelay(ctx context.Context, in *PurgeWorkerRelayRequest, opts ...grpc.CallOption) (*PurgeWorkerRelayResponse, error)
	// MigrateRelay request migrate old dm-woker to a new one.
	MigrateWorkerRelay(ctx context.Context, in *MigrateWorkerRelayRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error)
	// CheckTask checks legality of task configuration
	CheckTask(ctx context.Context, in *CheckTaskRequest, opts ...grpc.CallOption) (*CheckTaskResponse, error)
	// Operate an upstream MySQL source.
	OperateSource(ctx context.Context, in *OperateSourceRequest, opts ...grpc.CallOption) (*OperateSourceResponse, error)
	// RegisterWorker register the dm-workers.
	RegisterWorker(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*RegisterWorkerResponse, error)
	// OfflineWorker offline the dm-workers.
	OfflineWorker(ctx context.Context, in *OfflineWorkerRequest, opts ...grpc.CallOption) (*OfflineWorkerResponse, error)
	// ListMember list member master information
	ListMemberMaster(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberMasterResponse, error)
	// ListMember list member worker information
	ListMemberWorker(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberWorkerResponse, error)
	// ListMember list member leader information
	ListMemberLeader(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberLeaderResponse, error)
}

type masterClient struct {
	cc *grpc.ClientConn
}

func NewMasterClient(cc *grpc.ClientConn) MasterClient {
	return &masterClient{cc}
}

func (c *masterClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error) {
	out := new(StartTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/StartTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error) {
	out := new(OperateTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error) {
	out := new(UpdateTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error) {
	out := new(QueryStatusListResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/QueryStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) QueryError(ctx context.Context, in *QueryErrorListRequest, opts ...grpc.CallOption) (*QueryErrorListResponse, error) {
	out := new(QueryErrorListResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/QueryError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ShowDDLLocks(ctx context.Context, in *ShowDDLLocksRequest, opts ...grpc.CallOption) (*ShowDDLLocksResponse, error) {
	out := new(ShowDDLLocksResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/ShowDDLLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*UnlockDDLLockResponse, error) {
	out := new(UnlockDDLLockResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UnlockDDLLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateMasterConfig(ctx context.Context, in *UpdateMasterConfigRequest, opts ...grpc.CallOption) (*UpdateMasterConfigResponse, error) {
	out := new(UpdateMasterConfigResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateMasterConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateWorkerRelayConfig(ctx context.Context, in *UpdateWorkerRelayConfigRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error) {
	out := new(CommonWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateWorkerRelayConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*HandleSQLsResponse, error) {
	out := new(HandleSQLsResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/HandleSQLs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) SwitchWorkerRelayMaster(ctx context.Context, in *SwitchWorkerRelayMasterRequest, opts ...grpc.CallOption) (*SwitchWorkerRelayMasterResponse, error) {
	out := new(SwitchWorkerRelayMasterResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/SwitchWorkerRelayMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateWorkerRelayTask(ctx context.Context, in *OperateWorkerRelayRequest, opts ...grpc.CallOption) (*OperateWorkerRelayResponse, error) {
	out := new(OperateWorkerRelayResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateWorkerRelayTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) PurgeWorkerRelay(ctx context.Context, in *PurgeWorkerRelayRequest, opts ...grpc.CallOption) (*PurgeWorkerRelayResponse, error) {
	out := new(PurgeWorkerRelayResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/PurgeWorkerRelay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) MigrateWorkerRelay(ctx context.Context, in *MigrateWorkerRelayRequest, opts ...grpc.CallOption) (*CommonWorkerResponse, error) {
	out := new(CommonWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/MigrateWorkerRelay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) CheckTask(ctx context.Context, in *CheckTaskRequest, opts ...grpc.CallOption) (*CheckTaskResponse, error) {
	out := new(CheckTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/CheckTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateSource(ctx context.Context, in *OperateSourceRequest, opts ...grpc.CallOption) (*OperateSourceResponse, error) {
	out := new(OperateSourceResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) RegisterWorker(ctx context.Context, in *RegisterWorkerRequest, opts ...grpc.CallOption) (*RegisterWorkerResponse, error) {
	out := new(RegisterWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/RegisterWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OfflineWorker(ctx context.Context, in *OfflineWorkerRequest, opts ...grpc.CallOption) (*OfflineWorkerResponse, error) {
	out := new(OfflineWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OfflineWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ListMemberMaster(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberMasterResponse, error) {
	out := new(ListMemberMasterResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/ListMemberMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ListMemberWorker(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberWorkerResponse, error) {
	out := new(ListMemberWorkerResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/ListMemberWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ListMemberLeader(ctx context.Context, in *ListMemberRequest, opts ...grpc.CallOption) (*ListMemberLeaderResponse, error) {
	out := new(ListMemberLeaderResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/ListMemberLeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterServer is the server API for Master service.
type MasterServer interface {
	StartTask(context.Context, *StartTaskRequest) (*StartTaskResponse, error)
	OperateTask(context.Context, *OperateTaskRequest) (*OperateTaskResponse, error)
	UpdateTask(context.Context, *UpdateTaskRequest) (*UpdateTaskResponse, error)
	QueryStatus(context.Context, *QueryStatusListRequest) (*QueryStatusListResponse, error)
	QueryError(context.Context, *QueryErrorListRequest) (*QueryErrorListResponse, error)
	// show un-resolved DDL locks
	ShowDDLLocks(context.Context, *ShowDDLLocksRequest) (*ShowDDLLocksResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(context.Context, *UnlockDDLLockRequest) (*UnlockDDLLockResponse, error)
	UpdateMasterConfig(context.Context, *UpdateMasterConfigRequest) (*UpdateMasterConfigResponse, error)
	UpdateWorkerRelayConfig(context.Context, *UpdateWorkerRelayConfigRequest) (*CommonWorkerResponse, error)
	HandleSQLs(context.Context, *HandleSQLsRequest) (*HandleSQLsResponse, error)
	// SwitchWorkerRelayMaster requests some dm-workers to switch relay unit's master server
	SwitchWorkerRelayMaster(context.Context, *SwitchWorkerRelayMasterRequest) (*SwitchWorkerRelayMasterResponse, error)
	// OperateWorkerRelayTask requests some dm-workers to operate relay unit
	OperateWorkerRelayTask(context.Context, *OperateWorkerRelayRequest) (*OperateWorkerRelayResponse, error)
	// PurgeWorkerRelay purges relay log files for some dm-workers
	PurgeWorkerRelay(context.Context, *PurgeWorkerRelayRequest) (*PurgeWorkerRelayResponse, error)
	// MigrateRelay request migrate old dm-woker to a new one.
	MigrateWorkerRelay(context.Context, *MigrateWorkerRelayRequest) (*CommonWorkerResponse, error)
	// CheckTask checks legality of task configuration
	CheckTask(context.Context, *CheckTaskRequest) (*CheckTaskResponse, error)
	// Operate an upstream MySQL source.
	OperateSource(context.Context, *OperateSourceRequest) (*OperateSourceResponse, error)
	// RegisterWorker register the dm-workers.
	RegisterWorker(context.Context, *RegisterWorkerRequest) (*RegisterWorkerResponse, error)
	// OfflineWorker offline the dm-workers.
	OfflineWorker(context.Context, *OfflineWorkerRequest) (*OfflineWorkerResponse, error)
	// ListMember list member master information
	ListMemberMaster(context.Context, *ListMemberRequest) (*ListMemberMasterResponse, error)
	// ListMember list member worker information
	ListMemberWorker(context.Context, *ListMemberRequest) (*ListMemberWorkerResponse, error)
	// ListMember list member leader information
	ListMemberLeader(context.Context, *ListMemberRequest) (*ListMemberLeaderResponse, error)
}

// UnimplementedMasterServer can be embedded to have forward compatible implementations.
type UnimplementedMasterServer struct {
}

func (*UnimplementedMasterServer) StartTask(ctx context.Context, req *StartTaskRequest) (*StartTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTask not implemented")
}
func (*UnimplementedMasterServer) OperateTask(ctx context.Context, req *OperateTaskRequest) (*OperateTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateTask not implemented")
}
func (*UnimplementedMasterServer) UpdateTask(ctx context.Context, req *UpdateTaskRequest) (*UpdateTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTask not implemented")
}
func (*UnimplementedMasterServer) QueryStatus(ctx context.Context, req *QueryStatusListRequest) (*QueryStatusListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryStatus not implemented")
}
func (*UnimplementedMasterServer) QueryError(ctx context.Context, req *QueryErrorListRequest) (*QueryErrorListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryError not implemented")
}
func (*UnimplementedMasterServer) ShowDDLLocks(ctx context.Context, req *ShowDDLLocksRequest) (*ShowDDLLocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowDDLLocks not implemented")
}
func (*UnimplementedMasterServer) UnlockDDLLock(ctx context.Context, req *UnlockDDLLockRequest) (*UnlockDDLLockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockDDLLock not implemented")
}
func (*UnimplementedMasterServer) UpdateMasterConfig(ctx context.Context, req *UpdateMasterConfigRequest) (*UpdateMasterConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMasterConfig not implemented")
}
func (*UnimplementedMasterServer) UpdateWorkerRelayConfig(ctx context.Context, req *UpdateWorkerRelayConfigRequest) (*CommonWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkerRelayConfig not implemented")
}
func (*UnimplementedMasterServer) HandleSQLs(ctx context.Context, req *HandleSQLsRequest) (*HandleSQLsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleSQLs not implemented")
}
func (*UnimplementedMasterServer) SwitchWorkerRelayMaster(ctx context.Context, req *SwitchWorkerRelayMasterRequest) (*SwitchWorkerRelayMasterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchWorkerRelayMaster not implemented")
}
func (*UnimplementedMasterServer) OperateWorkerRelayTask(ctx context.Context, req *OperateWorkerRelayRequest) (*OperateWorkerRelayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateWorkerRelayTask not implemented")
}
func (*UnimplementedMasterServer) PurgeWorkerRelay(ctx context.Context, req *PurgeWorkerRelayRequest) (*PurgeWorkerRelayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PurgeWorkerRelay not implemented")
}
func (*UnimplementedMasterServer) MigrateWorkerRelay(ctx context.Context, req *MigrateWorkerRelayRequest) (*CommonWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateWorkerRelay not implemented")
}
func (*UnimplementedMasterServer) CheckTask(ctx context.Context, req *CheckTaskRequest) (*CheckTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckTask not implemented")
}
func (*UnimplementedMasterServer) OperateSource(ctx context.Context, req *OperateSourceRequest) (*OperateSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateSource not implemented")
}
func (*UnimplementedMasterServer) RegisterWorker(ctx context.Context, req *RegisterWorkerRequest) (*RegisterWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterWorker not implemented")
}
func (*UnimplementedMasterServer) OfflineWorker(ctx context.Context, req *OfflineWorkerRequest) (*OfflineWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OfflineWorker not implemented")
}
func (*UnimplementedMasterServer) ListMemberMaster(ctx context.Context, req *ListMemberRequest) (*ListMemberMasterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMemberMaster not implemented")
}
func (*UnimplementedMasterServer) ListMemberWorker(ctx context.Context, req *ListMemberRequest) (*ListMemberWorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMemberWorker not implemented")
}
func (*UnimplementedMasterServer) ListMemberLeader(ctx context.Context, req *ListMemberRequest) (*ListMemberLeaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMemberLeader not implemented")
}

func RegisterMasterServer(s *grpc.Server, srv MasterServer) {
	s.RegisterService(&_Master_serviceDesc, srv)
}

func _Master_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).StartTask(ctx, req.(*StartTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateTask(ctx, req.(*OperateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_QueryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStatusListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).QueryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/QueryStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).QueryStatus(ctx, req.(*QueryStatusListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_QueryError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryErrorListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).QueryError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/QueryError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).QueryError(ctx, req.(*QueryErrorListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ShowDDLLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowDDLLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ShowDDLLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ShowDDLLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ShowDDLLocks(ctx, req.(*ShowDDLLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UnlockDDLLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockDDLLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UnlockDDLLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UnlockDDLLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UnlockDDLLock(ctx, req.(*UnlockDDLLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateMasterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMasterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateMasterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateMasterConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateMasterConfig(ctx, req.(*UpdateMasterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateWorkerRelayConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkerRelayConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateWorkerRelayConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateWorkerRelayConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateWorkerRelayConfig(ctx, req.(*UpdateWorkerRelayConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_HandleSQLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleSQLsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).HandleSQLs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/HandleSQLs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).HandleSQLs(ctx, req.(*HandleSQLsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_SwitchWorkerRelayMaster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchWorkerRelayMasterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).SwitchWorkerRelayMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/SwitchWorkerRelayMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).SwitchWorkerRelayMaster(ctx, req.(*SwitchWorkerRelayMasterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateWorkerRelayTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateWorkerRelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateWorkerRelayTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateWorkerRelayTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateWorkerRelayTask(ctx, req.(*OperateWorkerRelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_PurgeWorkerRelay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurgeWorkerRelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).PurgeWorkerRelay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/PurgeWorkerRelay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).PurgeWorkerRelay(ctx, req.(*PurgeWorkerRelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_MigrateWorkerRelay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateWorkerRelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).MigrateWorkerRelay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/MigrateWorkerRelay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).MigrateWorkerRelay(ctx, req.(*MigrateWorkerRelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_CheckTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).CheckTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/CheckTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).CheckTask(ctx, req.(*CheckTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateSource(ctx, req.(*OperateSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_RegisterWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).RegisterWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/RegisterWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).RegisterWorker(ctx, req.(*RegisterWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OfflineWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OfflineWorkerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OfflineWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OfflineWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OfflineWorker(ctx, req.(*OfflineWorkerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ListMemberMaster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ListMemberMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ListMemberMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ListMemberMaster(ctx, req.(*ListMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ListMemberWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ListMemberWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ListMemberWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ListMemberWorker(ctx, req.(*ListMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ListMemberLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ListMemberLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ListMemberLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ListMemberLeader(ctx, req.(*ListMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Master_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Master",
	HandlerType: (*MasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTask",
			Handler:    _Master_StartTask_Handler,
		},
		{
			MethodName: "OperateTask",
			Handler:    _Master_OperateTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Master_UpdateTask_Handler,
		},
		{
			MethodName: "QueryStatus",
			Handler:    _Master_QueryStatus_Handler,
		},
		{
			MethodName: "QueryError",
			Handler:    _Master_QueryError_Handler,
		},
		{
			MethodName: "ShowDDLLocks",
			Handler:    _Master_ShowDDLLocks_Handler,
		},
		{
			MethodName: "UnlockDDLLock",
			Handler:    _Master_UnlockDDLLock_Handler,
		},
		{
			MethodName: "UpdateMasterConfig",
			Handler:    _Master_UpdateMasterConfig_Handler,
		},
		{
			MethodName: "UpdateWorkerRelayConfig",
			Handler:    _Master_UpdateWorkerRelayConfig_Handler,
		},
		{
			MethodName: "HandleSQLs",
			Handler:    _Master_HandleSQLs_Handler,
		},
		{
			MethodName: "SwitchWorkerRelayMaster",
			Handler:    _Master_SwitchWorkerRelayMaster_Handler,
		},
		{
			MethodName: "OperateWorkerRelayTask",
			Handler:    _Master_OperateWorkerRelayTask_Handler,
		},
		{
			MethodName: "PurgeWorkerRelay",
			Handler:    _Master_PurgeWorkerRelay_Handler,
		},
		{
			MethodName: "MigrateWorkerRelay",
			Handler:    _Master_MigrateWorkerRelay_Handler,
		},
		{
			MethodName: "CheckTask",
			Handler:    _Master_CheckTask_Handler,
		},
		{
			MethodName: "OperateSource",
			Handler:    _Master_OperateSource_Handler,
		},
		{
			MethodName: "RegisterWorker",
			Handler:    _Master_RegisterWorker_Handler,
		},
		{
			MethodName: "OfflineWorker",
			Handler:    _Master_OfflineWorker_Handler,
		},
		{
			MethodName: "ListMemberMaster",
			Handler:    _Master_ListMemberMaster_Handler,
		},
		{
			MethodName: "ListMemberWorker",
			Handler:    _Master_ListMemberWorker_Handler,
		},
		{
			MethodName: "ListMemberLeader",
			Handler:    _Master_ListMemberLeader_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dmmaster.proto",
}

func (m *MigrateWorkerRelayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateWorkerRelayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateWorkerRelayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BinlogPos != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.BinlogPos))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BinlogName) > 0 {
		i -= len(m.BinlogName)
		copy(dAtA[i:], m.BinlogName)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.BinlogName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateWorkerRelayConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateWorkerRelayConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateWorkerRelayConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMasterConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMasterConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMasterConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMasterConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMasterConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMasterConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryStatusListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryStatusListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryStatusListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryStatusListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryErrorListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryErrorListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryErrorListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryErrorListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryErrorListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryErrorListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShowDDLLocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDDLLocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowDDLLocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DDLLock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DDLLock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DDLLock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Unsynced) > 0 {
		for iNdEx := len(m.Unsynced) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Unsynced[iNdEx])
			copy(dAtA[i:], m.Unsynced[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Unsynced[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Synced) > 0 {
		for iNdEx := len(m.Synced) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Synced[iNdEx])
			copy(dAtA[i:], m.Synced[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Synced[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DDLs) > 0 {
		for iNdEx := len(m.DDLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DDLs[iNdEx])
			copy(dAtA[i:], m.DDLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.DDLs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShowDDLLocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDDLLocksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShowDDLLocksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Locks) > 0 {
		for iNdEx := len(m.Locks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnlockDDLLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockDDLLockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockDDLLockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForceRemove {
		i--
		if m.ForceRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReplaceOwner) > 0 {
		i -= len(m.ReplaceOwner)
		copy(dAtA[i:], m.ReplaceOwner)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ReplaceOwner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockDDLLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockDDLLockResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockDDLLockResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SwitchWorkerRelayMasterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWorkerRelayMasterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchWorkerRelayMasterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SwitchWorkerRelayMasterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWorkerRelayMasterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SwitchWorkerRelayMasterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateWorkerRelayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateWorkerRelayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateWorkerRelayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateWorkerRelayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateWorkerRelayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateWorkerRelayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HandleSQLsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSQLsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandleSQLsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sharding {
		i--
		if m.Sharding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.SqlPattern) > 0 {
		i -= len(m.SqlPattern)
		copy(dAtA[i:], m.SqlPattern)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.SqlPattern)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BinlogPos) > 0 {
		i -= len(m.BinlogPos)
		copy(dAtA[i:], m.BinlogPos)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.BinlogPos)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HandleSQLsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSQLsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HandleSQLsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PurgeWorkerRelayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurgeWorkerRelayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurgeWorkerRelayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubDir) > 0 {
		i -= len(m.SubDir)
		copy(dAtA[i:], m.SubDir)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.SubDir)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x22
	}
	if m.Time != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.Inactive {
		i--
		if m.Inactive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PurgeWorkerRelayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PurgeWorkerRelayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PurgeWorkerRelayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckTaskRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		i -= len(m.Task)
		copy(dAtA[i:], m.Task)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateSourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateSourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateSourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperateSourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateSourceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperateSourceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWorkerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWorkerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWorkerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OfflineWorkerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfflineWorkerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfflineWorkerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OfflineWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfflineWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfflineWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemberMasterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberMasterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberMasterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientURLs) > 0 {
		for iNdEx := len(m.ClientURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClientURLs[iNdEx])
			copy(dAtA[i:], m.ClientURLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ClientURLs[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PeerURLs) > 0 {
		for iNdEx := len(m.PeerURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerURLs[iNdEx])
			copy(dAtA[i:], m.PeerURLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.PeerURLs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Alive {
		i--
		if m.Alive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MemberID != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemberWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Stage) > 0 {
		i -= len(m.Stage)
		copy(dAtA[i:], m.Stage)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Stage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListMemberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMemberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMemberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListMemberMasterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMemberMasterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMemberMasterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListMemberLeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMemberLeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMemberLeaderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientURLs) > 0 {
		for iNdEx := len(m.ClientURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClientURLs[iNdEx])
			copy(dAtA[i:], m.ClientURLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ClientURLs[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PeerURLs) > 0 {
		for iNdEx := len(m.PeerURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerURLs[iNdEx])
			copy(dAtA[i:], m.PeerURLs[iNdEx])
			i = encodeVarintDmmaster(dAtA, i, uint64(len(m.PeerURLs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Alive {
		i--
		if m.Alive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MemberID != 0 {
		i = encodeVarintDmmaster(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListMemberWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMemberWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMemberWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDmmaster(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result {
		i--
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDmmaster(dAtA []byte, offset int, v uint64) int {
	offset -= sovDmmaster(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MigrateWorkerRelayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BinlogName)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.BinlogPos != 0 {
		n += 1 + sovDmmaster(uint64(m.BinlogPos))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *UpdateWorkerRelayConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *StartTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *StartTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UpdateMasterConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *UpdateMasterConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UpdateTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UpdateTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryStatusListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryStatusListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryErrorListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryErrorListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ShowDDLLocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *DDLLock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.DDLs) > 0 {
		for _, s := range m.DDLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.Synced) > 0 {
		for _, s := range m.Synced {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.Unsynced) > 0 {
		for _, s := range m.Unsynced {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ShowDDLLocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UnlockDDLLockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.ReplaceOwner)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.ForceRemove {
		n += 2
	}
	return n
}

func (m *UnlockDDLLockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *SwitchWorkerRelayMasterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *SwitchWorkerRelayMasterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateWorkerRelayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateWorkerRelayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *HandleSQLsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	l = len(m.BinlogPos)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.SqlPattern)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.Sharding {
		n += 2
	}
	return n
}

func (m *HandleSQLsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *PurgeWorkerRelayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.Inactive {
		n += 2
	}
	if m.Time != 0 {
		n += 1 + sovDmmaster(uint64(m.Time))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.SubDir)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *PurgeWorkerRelayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *CheckTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *CheckTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OperateSourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OperateSourceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *RegisterWorkerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *RegisterWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OfflineWorkerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *OfflineWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *MemberMasterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.MemberID != 0 {
		n += 1 + sovDmmaster(uint64(m.MemberID))
	}
	if m.Alive {
		n += 2
	}
	if len(m.PeerURLs) > 0 {
		for _, s := range m.PeerURLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.ClientURLs) > 0 {
		for _, s := range m.ClientURLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *MemberWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Stage)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *ListMemberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListMemberMasterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ListMemberLeaderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.MemberID != 0 {
		n += 1 + sovDmmaster(uint64(m.MemberID))
	}
	if m.Alive {
		n += 2
	}
	if len(m.PeerURLs) > 0 {
		for _, s := range m.PeerURLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.ClientURLs) > 0 {
		for _, s := range m.ClientURLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ListMemberWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func sovDmmaster(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDmmaster(x uint64) (n int) {
	return sovDmmaster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MigrateWorkerRelayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateWorkerRelayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateWorkerRelayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinlogName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogPos", wireType)
			}
			m.BinlogPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinlogPos |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateWorkerRelayConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateWorkerRelayConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateWorkerRelayConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMasterConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMasterConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMasterConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMasterConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMasterConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMasterConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &QueryStatusResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= TaskOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= TaskOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &QueryStatusResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryErrorListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryErrorListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryErrorListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryErrorListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryErrorListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryErrorListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &QueryErrorResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDDLLocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDDLLocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDDLLocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DDLLock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDLLock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDLLock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DDLs = append(m.DDLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Synced = append(m.Synced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsynced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unsynced = append(m.Unsynced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDDLLocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDDLLocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDDLLocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &DDLLock{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockDDLLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplaceOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceRemove = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockDDLLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockDDLLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockDDLLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWorkerRelayMasterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWorkerRelayMasterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateWorkerRelayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateWorkerRelayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateWorkerRelayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= RelayOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateWorkerRelayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateWorkerRelayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateWorkerRelayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= RelayOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSQLsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSQLsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSQLsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= SQLOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogPos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinlogPos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlPattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlPattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sharding = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSQLsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSQLsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSQLsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PurgeWorkerRelayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurgeWorkerRelayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurgeWorkerRelayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inactive = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PurgeWorkerRelayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PurgeWorkerRelayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PurgeWorkerRelayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateSourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateSourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateSourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= SourceOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateSourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateSourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateSourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &CommonWorkerResponse{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWorkerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWorkerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWorkerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfflineWorkerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfflineWorkerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfflineWorkerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfflineWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfflineWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfflineWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberMasterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberMasterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberMasterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Alive = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerURLs = append(m.PeerURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientURLs = append(m.ClientURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMemberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMemberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMemberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMemberMasterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMemberMasterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMemberMasterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &MemberMasterResponse{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMemberLeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMemberLeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMemberLeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Alive = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerURLs = append(m.PeerURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientURLs = append(m.ClientURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMemberWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMemberWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMemberWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDmmaster
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &MemberWorkerResponse{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDmmaster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDmmaster
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDmmaster
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDmmaster
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDmmaster        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDmmaster          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDmmaster = fmt.Errorf("proto: unexpected end of group")
)
