// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.2 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(ctx echo.Context) error
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(ctx echo.Context) error
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(ctx echo.Context) error
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(ctx echo.Context) error
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(ctx echo.Context, sourceName string) error
	// enable relay log function for the data source
	// (PATCH /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(ctx echo.Context, sourceName string) error
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(ctx echo.Context, sourceName string) error
	// disable relay log function for the data source
	// (PATCH /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(ctx echo.Context, sourceName string) error
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(ctx echo.Context) error
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(ctx echo.Context) error
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(ctx echo.Context, taskName string) error
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(ctx echo.Context, taskName string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetDocJSON converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocJSON(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocJSON(ctx)
	return err
}

// GetDocHTML converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocHTML(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocHTML(ctx)
	return err
}

// DMAPIGetSourceList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceList(ctx)
	return err
}

// DMAPICreateSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPICreateSource(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPICreateSource(ctx)
	return err
}

// DMAPIDeleteSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteSource(ctx, sourceName)
	return err
}

// DMAPIStartRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartRelay(ctx, sourceName)
	return err
}

// DMAPIGetSourceStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceStatus(ctx, sourceName)
	return err
}

// DMAPIStopRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStopRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStopRelay(ctx, sourceName)
	return err
}

// DMAPIGetTaskList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskList(ctx)
	return err
}

// DMAPIStartTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartTask(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartTask(ctx)
	return err
}

// DMAPIDeleteTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteTask(ctx, taskName)
	return err
}

// DMAPIGetTaskStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskStatus(ctx, taskName)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/dm.json", wrapper.GetDocJSON)
	router.GET(baseURL+"/api/v1/docs", wrapper.GetDocHTML)
	router.GET(baseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)
	router.POST(baseURL+"/api/v1/sources", wrapper.DMAPICreateSource)
	router.DELETE(baseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)
	router.PATCH(baseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)
	router.GET(baseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)
	router.PATCH(baseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)
	router.GET(baseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)
	router.POST(baseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)
	router.DELETE(baseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)
	router.GET(baseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HZri72MExp/sb/b/DQAA///h/uczR0YAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
