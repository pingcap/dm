// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.2 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get cluster master node list
	// (GET /api/v1/cluster/masters)
	DMAPIGetClusterMasterList(ctx echo.Context) error
	// offline master node
	// (DELETE /api/v1/cluster/masters/{master-name})
	DMAPIOfflineMasterNode(ctx echo.Context, masterName string) error
	// get cluster worker node list
	// (GET /api/v1/cluster/workers)
	DMAPIGetClusterWorkerList(ctx echo.Context) error
	// offline worker node
	// (DELETE /api/v1/cluster/workers/{worker-name})
	DMAPIOfflineWorkerNode(ctx echo.Context, workerName string) error
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(ctx echo.Context) error
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(ctx echo.Context) error
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(ctx echo.Context, params DMAPIGetSourceListParams) error
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(ctx echo.Context) error
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(ctx echo.Context, sourceName string, params DMAPIDeleteSourceParams) error
	// pause relay log function for the data source
	// (POST /api/v1/sources/{source-name}/pause-relay)
	DMAPIPauseRelay(ctx echo.Context, sourceName string) error
	// resume relay log function for the data source
	// (POST /api/v1/sources/{source-name}/resume-relay)
	DMAPIResumeRelay(ctx echo.Context, sourceName string) error
	// get source schema list
	// (GET /api/v1/sources/{source-name}/schemas)
	DMAPIGetSourceSchemaList(ctx echo.Context, sourceName string) error
	// get source table list
	// (GET /api/v1/sources/{source-name}/schemas/{schema-name})
	DMAPIGetSourceTableList(ctx echo.Context, sourceName string, schemaName string) error
	// enable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(ctx echo.Context, sourceName string) error
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(ctx echo.Context, sourceName string) error
	// disable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(ctx echo.Context, sourceName string) error
	// transfer source to a free worker
	// (POST /api/v1/sources/{source-name}/transfer)
	DMAPITransferSource(ctx echo.Context, sourceName string) error
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(ctx echo.Context) error
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(ctx echo.Context) error
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(ctx echo.Context, taskName string, params DMAPIDeleteTaskParams) error
	// pause task
	// (POST /api/v1/tasks/{task-name}/pause)
	DMAPPauseTask(ctx echo.Context, taskName string) error
	// resume task
	// (POST /api/v1/tasks/{task-name}/resume)
	DMAPIResumeTask(ctx echo.Context, taskName string) error
	// get task source schema list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas)
	DMAPIGetTaskSourceSchemaList(ctx echo.Context, taskName string, sourceName string) error
	// get task source table list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name})
	DMAPIGetTaskSourceTableList(ctx echo.Context, taskName string, sourceName string, schemaName string) error
	// delete task source table structure
	// (DELETE /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIDeleteTaskSourceTableStructure(ctx echo.Context, taskName string, sourceName string, schemaName string, tableName string) error
	// get task source table structure
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIGetTaskSourceTableStructure(ctx echo.Context, taskName string, sourceName string, schemaName string, tableName string) error
	// operate task source table structure
	// (PUT /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIOperateTaskSourceTableStructure(ctx echo.Context, taskName string, sourceName string, schemaName string, tableName string) error
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(ctx echo.Context, taskName string, params DMAPIGetTaskStatusParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// DMAPIGetClusterMasterList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetClusterMasterList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetClusterMasterList(ctx)
	return err
}

// DMAPIOfflineMasterNode converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIOfflineMasterNode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "master-name" -------------
	var masterName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "master-name", runtime.ParamLocationPath, ctx.Param("master-name"), &masterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter master-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIOfflineMasterNode(ctx, masterName)
	return err
}

// DMAPIGetClusterWorkerList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetClusterWorkerList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetClusterWorkerList(ctx)
	return err
}

// DMAPIOfflineWorkerNode converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIOfflineWorkerNode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker-name" -------------
	var workerName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "worker-name", runtime.ParamLocationPath, ctx.Param("worker-name"), &workerName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIOfflineWorkerNode(ctx, workerName)
	return err
}

// GetDocJSON converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocJSON(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocJSON(ctx)
	return err
}

// GetDocHTML converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocHTML(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocHTML(ctx)
	return err
}

// DMAPIGetSourceList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceList(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetSourceListParams
	// ------------- Optional query parameter "with_status" -------------

	err = runtime.BindQueryParameter("form", true, false, "with_status", ctx.QueryParams(), &params.WithStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter with_status: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceList(ctx, params)
	return err
}

// DMAPICreateSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPICreateSource(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPICreateSource(ctx)
	return err
}

// DMAPIDeleteSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteSourceParams
	// ------------- Optional query parameter "force" -------------

	err = runtime.BindQueryParameter("form", true, false, "force", ctx.QueryParams(), &params.Force)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter force: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteSource(ctx, sourceName, params)
	return err
}

// DMAPIPauseRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIPauseRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIPauseRelay(ctx, sourceName)
	return err
}

// DMAPIResumeRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIResumeRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIResumeRelay(ctx, sourceName)
	return err
}

// DMAPIGetSourceSchemaList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceSchemaList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceSchemaList(ctx, sourceName)
	return err
}

// DMAPIGetSourceTableList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceTableList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceTableList(ctx, sourceName, schemaName)
	return err
}

// DMAPIStartRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartRelay(ctx, sourceName)
	return err
}

// DMAPIGetSourceStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceStatus(ctx, sourceName)
	return err
}

// DMAPIStopRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStopRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStopRelay(ctx, sourceName)
	return err
}

// DMAPITransferSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPITransferSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPITransferSource(ctx, sourceName)
	return err
}

// DMAPIGetTaskList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskList(ctx)
	return err
}

// DMAPIStartTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartTask(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartTask(ctx)
	return err
}

// DMAPIDeleteTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteTaskParams
	// ------------- Optional query parameter "source_name_list" -------------

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", ctx.QueryParams(), &params.SourceNameList)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_name_list: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteTask(ctx, taskName, params)
	return err
}

// DMAPPauseTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPPauseTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPPauseTask(ctx, taskName)
	return err
}

// DMAPIResumeTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIResumeTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIResumeTask(ctx, taskName)
	return err
}

// DMAPIGetTaskSourceSchemaList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskSourceSchemaList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskSourceSchemaList(ctx, taskName, sourceName)
	return err
}

// DMAPIGetTaskSourceTableList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskSourceTableList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskSourceTableList(ctx, taskName, sourceName, schemaName)
	return err
}

// DMAPIDeleteTaskSourceTableStructure converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteTaskSourceTableStructure(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table-name", runtime.ParamLocationPath, ctx.Param("table-name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteTaskSourceTableStructure(ctx, taskName, sourceName, schemaName, tableName)
	return err
}

// DMAPIGetTaskSourceTableStructure converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskSourceTableStructure(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table-name", runtime.ParamLocationPath, ctx.Param("table-name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskSourceTableStructure(ctx, taskName, sourceName, schemaName, tableName)
	return err
}

// DMAPIOperateTaskSourceTableStructure converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIOperateTaskSourceTableStructure(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table-name", runtime.ParamLocationPath, ctx.Param("table-name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIOperateTaskSourceTableStructure(ctx, taskName, sourceName, schemaName, tableName)
	return err
}

// DMAPIGetTaskStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskStatusParams
	// ------------- Optional query parameter "source-name-list" -------------

	err = runtime.BindQueryParameter("form", true, false, "source-name-list", ctx.QueryParams(), &params.SourceNameList)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name-list: %s", err))
	}

	// ------------- Optional query parameter "stage" -------------

	err = runtime.BindQueryParameter("form", true, false, "stage", ctx.QueryParams(), &params.Stage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskStatus(ctx, taskName, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/cluster/masters", wrapper.DMAPIGetClusterMasterList)
	router.DELETE(baseURL+"/api/v1/cluster/masters/:master-name", wrapper.DMAPIOfflineMasterNode)
	router.GET(baseURL+"/api/v1/cluster/workers", wrapper.DMAPIGetClusterWorkerList)
	router.DELETE(baseURL+"/api/v1/cluster/workers/:worker-name", wrapper.DMAPIOfflineWorkerNode)
	router.GET(baseURL+"/api/v1/dm.json", wrapper.GetDocJSON)
	router.GET(baseURL+"/api/v1/docs", wrapper.GetDocHTML)
	router.GET(baseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)
	router.POST(baseURL+"/api/v1/sources", wrapper.DMAPICreateSource)
	router.DELETE(baseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)
	router.POST(baseURL+"/api/v1/sources/:source-name/pause-relay", wrapper.DMAPIPauseRelay)
	router.POST(baseURL+"/api/v1/sources/:source-name/resume-relay", wrapper.DMAPIResumeRelay)
	router.GET(baseURL+"/api/v1/sources/:source-name/schemas", wrapper.DMAPIGetSourceSchemaList)
	router.GET(baseURL+"/api/v1/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetSourceTableList)
	router.POST(baseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)
	router.GET(baseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)
	router.POST(baseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)
	router.POST(baseURL+"/api/v1/sources/:source-name/transfer", wrapper.DMAPITransferSource)
	router.GET(baseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)
	router.POST(baseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)
	router.DELETE(baseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)
	router.POST(baseURL+"/api/v1/tasks/:task-name/pause", wrapper.DMAPPauseTask)
	router.POST(baseURL+"/api/v1/tasks/:task-name/resume", wrapper.DMAPIResumeTask)
	router.GET(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas", wrapper.DMAPIGetTaskSourceSchemaList)
	router.GET(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetTaskSourceTableList)
	router.DELETE(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIDeleteTaskSourceTableStructure)
	router.GET(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIGetTaskSourceTableStructure)
	router.PUT(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIOperateTaskSourceTableStructure)
	router.GET(baseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
